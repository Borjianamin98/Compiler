Warning : *** Production "var_declrations ::= var_dcl " never reduced
Warning : *** Production "var_declrations ::= var_dcl var_declrations " never reduced
Warning : *** Production "struct_dcl ::= RECORD IDENTIFIER BEGIN var_declrations END RECORD SEMICOLON " never reduced
Warning : *** Production "argument ::= typeName IDENTIFIER array_part_no_val " never reduced
Warning : *** Production "argument ::= typeName IDENTIFIER " never reduced
Warning : *** Production "arguments ::= argument " never reduced
Warning : *** Production "arguments ::= argument COMMA arguments " never reduced
Warning : *** Production "func_signature ::= IDENTIFIER LPAREN RPAREN block " never reduced
Warning : *** Production "func_signature ::= IDENTIFIER LPAREN arguments RPAREN block " never reduced
Warning : *** Production "func_signature ::= IDENTIFIER LPAREN RPAREN SEMICOLON " never reduced
Warning : *** Production "func_signature ::= IDENTIFIER LPAREN arguments RPAREN SEMICOLON " never reduced
Warning : *** Production "function_dcl ::= FUNCTION VOID func_signature " never reduced
Warning : *** Production "function_dcl ::= FUNCTION typeName func_signature " never reduced
Warning : *** Production "extern_dcl ::= EXTERN typeName IDENTIFIER SEMICOLON " never reduced
Warning : *** Production "program ::= " never reduced
Warning : *** Production "program ::= struct_dcl program " never reduced
Warning : *** Production "program ::= extern_dcl program " never reduced
Warning : *** Production "program ::= function_dcl program " never reduced
Warning : *** Production "program ::= var_dcl program " never reduced
===== Viable Prefix Recognizer =====
START lalr_state [0]: {
  [block ::= (*) BEGIN END , {EOF }]
  [block ::= (*) BEGIN NT$4 block_part NT$5 END , {EOF }]
  [begining ::= (*) block , {EOF }]
  [$START ::= (*) begining EOF , {EOF }]
}
transition on block to state [3]
transition on BEGIN to state [2]
transition on begining to state [1]

-------------------
lalr_state [1]: {
  [$START ::= begining (*) EOF , {EOF }]
}
transition on EOF to state [229]

-------------------
lalr_state [2]: {
  [block ::= BEGIN (*) END , {EOF IDENTIFIER INT LONG FLOAT DOUBLE BOOL CHAR STRING AUTO IF ELSE RETURN BREAK CONTINUE SWITCH CASE DEFAULT END FOR REPEAT UNTIL FOREACH CONST PRINTLN INPUT }]
  [NT$4 ::= (*) , {IDENTIFIER INT LONG FLOAT DOUBLE BOOL CHAR STRING AUTO IF RETURN BREAK CONTINUE SWITCH FOR REPEAT FOREACH CONST PRINTLN INPUT }]
  [block ::= BEGIN (*) NT$4 block_part NT$5 END , {EOF IDENTIFIER INT LONG FLOAT DOUBLE BOOL CHAR STRING AUTO IF ELSE RETURN BREAK CONTINUE SWITCH CASE DEFAULT END FOR REPEAT UNTIL FOREACH CONST PRINTLN INPUT }]
}
transition on NT$4 to state [5]
transition on END to state [4]

-------------------
lalr_state [3]: {
  [begining ::= block (*) , {EOF }]
}

-------------------
lalr_state [4]: {
  [block ::= BEGIN END (*) , {EOF IDENTIFIER INT LONG FLOAT DOUBLE BOOL CHAR STRING AUTO IF ELSE RETURN BREAK CONTINUE SWITCH CASE DEFAULT END FOR REPEAT UNTIL FOREACH CONST PRINTLN INPUT }]
}

-------------------
lalr_state [5]: {
  [cond_stmt ::= (*) SWITCH LPAREN expr RPAREN OF COLON BEGIN case_part DEFAULT COLON block END , {IDENTIFIER INT LONG FLOAT DOUBLE BOOL CHAR STRING AUTO IF RETURN BREAK CONTINUE SWITCH END FOR REPEAT FOREACH CONST PRINTLN INPUT }]
  [assignment ::= (*) variable DIVIDE_ASSIGN expr , {SEMICOLON }]
  [statement ::= (*) loop_stmt , {IDENTIFIER INT LONG FLOAT DOUBLE BOOL CHAR STRING AUTO IF RETURN BREAK CONTINUE SWITCH END FOR REPEAT FOREACH CONST PRINTLN INPUT }]
  [block_part ::= (*) block_body , {END }]
  [variable ::= (*) variable LBRACKET expr RBRACKET , {LBRACKET DOT DIRECT_ASSIGN SUM_ASSIGN DIFF_ASSIGN MULT_ASSIGN DIVIDE_ASSIGN MOD_ASSIGN }]
  [var_dcl ::= (*) CONST typeName array_part_no_val NT$0 const_var_dcl_p SEMICOLON , {IDENTIFIER INT LONG FLOAT DOUBLE BOOL CHAR STRING AUTO IF RETURN BREAK CONTINUE SWITCH END FOR REPEAT FOREACH CONST PRINTLN INPUT }]
  [base_type ::= (*) LONG , {LRBRACKET IDENTIFIER }]
  [loop_stmt ::= (*) FOR LPAREN for_init_part SEMICOLON expr SEMICOLON expr RPAREN block , {IDENTIFIER INT LONG FLOAT DOUBLE BOOL CHAR STRING AUTO IF RETURN BREAK CONTINUE SWITCH END FOR REPEAT FOREACH CONST PRINTLN INPUT }]
  [assignment ::= (*) variable DIRECT_ASSIGN expr , {SEMICOLON }]
  [block_body ::= (*) PRINTLN LPAREN expr RPAREN SEMICOLON , {IDENTIFIER INT LONG FLOAT DOUBLE BOOL CHAR STRING AUTO IF RETURN BREAK CONTINUE SWITCH END FOR REPEAT FOREACH CONST PRINTLN INPUT }]
  [base_type ::= (*) STRING , {LRBRACKET IDENTIFIER }]
  [cond_stmt ::= (*) SWITCH LPAREN expr RPAREN OF COLON BEGIN case_part END , {IDENTIFIER INT LONG FLOAT DOUBLE BOOL CHAR STRING AUTO IF RETURN BREAK CONTINUE SWITCH END FOR REPEAT FOREACH CONST PRINTLN INPUT }]
  [assignment ::= (*) variable MOD_ASSIGN expr , {SEMICOLON }]
  [statement ::= (*) RETURN SEMICOLON , {IDENTIFIER INT LONG FLOAT DOUBLE BOOL CHAR STRING AUTO IF RETURN BREAK CONTINUE SWITCH END FOR REPEAT FOREACH CONST PRINTLN INPUT }]
  [block_part ::= (*) block_body block_part , {END }]
  [variable ::= (*) variable DOT IDENTIFIER , {LBRACKET DOT DIRECT_ASSIGN SUM_ASSIGN DIFF_ASSIGN MULT_ASSIGN DIVIDE_ASSIGN MOD_ASSIGN }]
  [base_type ::= (*) FLOAT , {LRBRACKET IDENTIFIER }]
  [loop_stmt ::= (*) FOR LPAREN for_init_part SEMICOLON expr SEMICOLON RPAREN block , {IDENTIFIER INT LONG FLOAT DOUBLE BOOL CHAR STRING AUTO IF RETURN BREAK CONTINUE SWITCH END FOR REPEAT FOREACH CONST PRINTLN INPUT }]
  [assignment ::= (*) variable SUM_ASSIGN expr , {SEMICOLON }]
  [block_body ::= (*) PRINTLN LPAREN RPAREN SEMICOLON , {IDENTIFIER INT LONG FLOAT DOUBLE BOOL CHAR STRING AUTO IF RETURN BREAK CONTINUE SWITCH END FOR REPEAT FOREACH CONST PRINTLN INPUT }]
  [var_dcl ::= (*) AUTO NT$3 const_var_dcl_p SEMICOLON , {IDENTIFIER INT LONG FLOAT DOUBLE BOOL CHAR STRING AUTO IF RETURN BREAK CONTINUE SWITCH END FOR REPEAT FOREACH CONST PRINTLN INPUT }]
  [typeName ::= (*) base_type , {LRBRACKET IDENTIFIER }]
  [method_cal ::= (*) IDENTIFIER LPAREN parameters RPAREN , {SEMICOLON }]
  [statement ::= (*) RETURN expr SEMICOLON , {IDENTIFIER INT LONG FLOAT DOUBLE BOOL CHAR STRING AUTO IF RETURN BREAK CONTINUE SWITCH END FOR REPEAT FOREACH CONST PRINTLN INPUT }]
  [block_body ::= (*) var_dcl , {IDENTIFIER INT LONG FLOAT DOUBLE BOOL CHAR STRING AUTO IF RETURN BREAK CONTINUE SWITCH END FOR REPEAT FOREACH CONST PRINTLN INPUT }]
  [var_dcl ::= (*) typeName array_part_no_val NT$1 var_dcl_p SEMICOLON , {IDENTIFIER INT LONG FLOAT DOUBLE BOOL CHAR STRING AUTO IF RETURN BREAK CONTINUE SWITCH END FOR REPEAT FOREACH CONST PRINTLN INPUT }]
  [base_type ::= (*) DOUBLE , {LRBRACKET IDENTIFIER }]
  [loop_stmt ::= (*) REPEAT block UNTIL LPAREN expr RPAREN SEMICOLON , {IDENTIFIER INT LONG FLOAT DOUBLE BOOL CHAR STRING AUTO IF RETURN BREAK CONTINUE SWITCH END FOR REPEAT FOREACH CONST PRINTLN INPUT }]
  [cond_stmt ::= (*) IF LPAREN expr RPAREN block ELSE block , {IDENTIFIER INT LONG FLOAT DOUBLE BOOL CHAR STRING AUTO IF RETURN BREAK CONTINUE SWITCH END FOR REPEAT FOREACH CONST PRINTLN INPUT }]
  [block ::= BEGIN NT$4 (*) block_part NT$5 END , {EOF IDENTIFIER INT LONG FLOAT DOUBLE BOOL CHAR STRING AUTO IF ELSE RETURN BREAK CONTINUE SWITCH CASE DEFAULT END FOR REPEAT UNTIL FOREACH CONST PRINTLN INPUT }]
  [assignment ::= (*) variable DIFF_ASSIGN expr , {SEMICOLON }]
  [statement ::= (*) assignment SEMICOLON , {IDENTIFIER INT LONG FLOAT DOUBLE BOOL CHAR STRING AUTO IF RETURN BREAK CONTINUE SWITCH END FOR REPEAT FOREACH CONST PRINTLN INPUT }]
  [typeName ::= (*) IDENTIFIER , {LRBRACKET IDENTIFIER }]
  [method_cal ::= (*) INPUT LPAREN typeName RPAREN SEMICOLON , {SEMICOLON }]
  [statement ::= (*) BREAK SEMICOLON , {IDENTIFIER INT LONG FLOAT DOUBLE BOOL CHAR STRING AUTO IF RETURN BREAK CONTINUE SWITCH END FOR REPEAT FOREACH CONST PRINTLN INPUT }]
  [block_body ::= (*) statement , {IDENTIFIER INT LONG FLOAT DOUBLE BOOL CHAR STRING AUTO IF RETURN BREAK CONTINUE SWITCH END FOR REPEAT FOREACH CONST PRINTLN INPUT }]
  [base_type ::= (*) BOOL , {LRBRACKET IDENTIFIER }]
  [loop_stmt ::= (*) FOREACH LPAREN IDENTIFIER IN variable RPAREN block , {IDENTIFIER INT LONG FLOAT DOUBLE BOOL CHAR STRING AUTO IF RETURN BREAK CONTINUE SWITCH END FOR REPEAT FOREACH CONST PRINTLN INPUT }]
  [cond_stmt ::= (*) IF LPAREN expr RPAREN block , {IDENTIFIER INT LONG FLOAT DOUBLE BOOL CHAR STRING AUTO IF RETURN BREAK CONTINUE SWITCH END FOR REPEAT FOREACH CONST PRINTLN INPUT }]
  [assignment ::= (*) variable MULT_ASSIGN expr , {SEMICOLON }]
  [statement ::= (*) cond_stmt , {IDENTIFIER INT LONG FLOAT DOUBLE BOOL CHAR STRING AUTO IF RETURN BREAK CONTINUE SWITCH END FOR REPEAT FOREACH CONST PRINTLN INPUT }]
  [variable ::= (*) IDENTIFIER , {LBRACKET DOT DIRECT_ASSIGN SUM_ASSIGN DIFF_ASSIGN MULT_ASSIGN DIVIDE_ASSIGN MOD_ASSIGN }]
  [base_type ::= (*) INT , {LRBRACKET IDENTIFIER }]
  [loop_stmt ::= (*) FOR LPAREN for_init_part SEMICOLON expr SEMICOLON assignment RPAREN block , {IDENTIFIER INT LONG FLOAT DOUBLE BOOL CHAR STRING AUTO IF RETURN BREAK CONTINUE SWITCH END FOR REPEAT FOREACH CONST PRINTLN INPUT }]
  [method_cal ::= (*) INPUT LPAREN RPAREN SEMICOLON , {SEMICOLON }]
  [statement ::= (*) CONTINUE SEMICOLON , {IDENTIFIER INT LONG FLOAT DOUBLE BOOL CHAR STRING AUTO IF RETURN BREAK CONTINUE SWITCH END FOR REPEAT FOREACH CONST PRINTLN INPUT }]
  [block_body ::= (*) method_cal SEMICOLON , {IDENTIFIER INT LONG FLOAT DOUBLE BOOL CHAR STRING AUTO IF RETURN BREAK CONTINUE SWITCH END FOR REPEAT FOREACH CONST PRINTLN INPUT }]
  [var_dcl ::= (*) CONST AUTO NT$2 const_var_dcl_p SEMICOLON , {IDENTIFIER INT LONG FLOAT DOUBLE BOOL CHAR STRING AUTO IF RETURN BREAK CONTINUE SWITCH END FOR REPEAT FOREACH CONST PRINTLN INPUT }]
  [base_type ::= (*) CHAR , {LRBRACKET IDENTIFIER }]
}
transition on DOUBLE to state [36]
transition on var_dcl to state [35]
transition on REPEAT to state [34]
transition on FOR to state [33]
transition on method_cal to state [32]
transition on BOOL to state [31]
transition on base_type to state [30]
transition on variable to state [29]
transition on CONST to state [28]
transition on cond_stmt to state [27]
transition on assignment to state [26]
transition on BREAK to state [25]
transition on AUTO to state [24]
transition on FOREACH to state [23]
transition on PRINTLN to state [22]
transition on FLOAT to state [21]
transition on loop_stmt to state [20]
transition on STRING to state [19]
transition on block_part to state [18]
transition on typeName to state [17]
transition on IF to state [16]
transition on SWITCH to state [15]
transition on IDENTIFIER to state [14]
transition on block_body to state [13]
transition on RETURN to state [12]
transition on CHAR to state [11]
transition on INT to state [10]
transition on statement to state [9]
transition on CONTINUE to state [8]
transition on LONG to state [7]
transition on INPUT to state [6]

-------------------
lalr_state [6]: {
  [method_cal ::= INPUT (*) LPAREN typeName RPAREN SEMICOLON , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [method_cal ::= INPUT (*) LPAREN RPAREN SEMICOLON , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
}
transition on LPAREN to state [223]

-------------------
lalr_state [7]: {
  [base_type ::= LONG (*) , {RPAREN LRBRACKET IDENTIFIER }]
}

-------------------
lalr_state [8]: {
  [statement ::= CONTINUE (*) SEMICOLON , {IDENTIFIER INT LONG FLOAT DOUBLE BOOL CHAR STRING AUTO IF RETURN BREAK CONTINUE SWITCH END FOR REPEAT FOREACH CONST PRINTLN INPUT }]
}
transition on SEMICOLON to state [222]

-------------------
lalr_state [9]: {
  [block_body ::= statement (*) , {IDENTIFIER INT LONG FLOAT DOUBLE BOOL CHAR STRING AUTO IF RETURN BREAK CONTINUE SWITCH END FOR REPEAT FOREACH CONST PRINTLN INPUT }]
}

-------------------
lalr_state [10]: {
  [base_type ::= INT (*) , {RPAREN LRBRACKET IDENTIFIER }]
}

-------------------
lalr_state [11]: {
  [base_type ::= CHAR (*) , {RPAREN LRBRACKET IDENTIFIER }]
}

-------------------
lalr_state [12]: {
  [expr ::= (*) expr BITWISE_OR expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR }]
  [variable ::= (*) variable LBRACKET expr RBRACKET , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR LBRACKET DOT PLUSPLUS MINUSMINUS }]
  [expr ::= (*) variable PLUSPLUS , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR }]
  [expr ::= (*) expr GREATER expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR }]
  [expr ::= (*) expr DIVIDE expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR }]
  [const_val ::= (*) FLOAT_CONST , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR }]
  [expr ::= (*) const_val , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR }]
  [expr ::= (*) variable , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR }]
  [expr ::= (*) expr EQUAL expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR }]
  [statement ::= RETURN (*) SEMICOLON , {IDENTIFIER INT LONG FLOAT DOUBLE BOOL CHAR STRING AUTO IF RETURN BREAK CONTINUE SWITCH END FOR REPEAT FOREACH CONST PRINTLN INPUT }]
  [variable ::= (*) variable DOT IDENTIFIER , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR LBRACKET DOT PLUSPLUS MINUSMINUS }]
  [expr ::= (*) method_cal , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR }]
  [expr ::= (*) expr LESS expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR }]
  [expr ::= (*) expr MOD expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR }]
  [const_val ::= (*) CHAR_CONST , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR }]
  [expr ::= (*) SIZEOF LPAREN typeName RPAREN , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR }]
  [expr ::= (*) MINUSMINUS variable , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR }]
  [expr ::= (*) expr NOT_EQUAL expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR }]
  [expr ::= (*) expr PLUS expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR }]
  [method_cal ::= (*) IDENTIFIER LPAREN parameters RPAREN , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR }]
  [statement ::= RETURN (*) expr SEMICOLON , {IDENTIFIER INT LONG FLOAT DOUBLE BOOL CHAR STRING AUTO IF RETURN BREAK CONTINUE SWITCH END FOR REPEAT FOREACH CONST PRINTLN INPUT }]
  [const_val ::= (*) INT_CONST , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR }]
  [expr ::= (*) MINUS expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR }]
  [expr ::= (*) expr AND expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR }]
  [expr ::= (*) expr BITWISE_AND expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR }]
  [const_val ::= (*) BOOL_CONST , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR }]
  [expr ::= (*) LPAREN base_type RPAREN expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR }]
  [expr ::= (*) PLUSPLUS variable , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR }]
  [expr ::= (*) expr GREATER_EQUAL expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR }]
  [expr ::= (*) expr MINUS expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR }]
  [method_cal ::= (*) INPUT LPAREN typeName RPAREN SEMICOLON , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR }]
  [const_val ::= (*) LONG_CONST , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR }]
  [expr ::= (*) BITWISE_NOT expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR }]
  [expr ::= (*) expr OR expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR }]
  [expr ::= (*) expr BITWISE_XOR expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR }]
  [const_val ::= (*) STRING_CONST , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR }]
  [variable ::= (*) IDENTIFIER , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR LBRACKET DOT PLUSPLUS MINUSMINUS }]
  [expr ::= (*) variable MINUSMINUS , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR }]
  [expr ::= (*) expr LESS_EQUAL expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR }]
  [expr ::= (*) expr MULTIPLY expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR }]
  [method_cal ::= (*) INPUT LPAREN RPAREN SEMICOLON , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR }]
  [const_val ::= (*) DOUBLE_CONST , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR }]
  [expr ::= (*) NOT expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR }]
  [expr ::= (*) LPAREN expr RPAREN , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR }]
}
transition on CHAR_CONST to state [58]
transition on method_cal to state [57]
transition on const_val to state [56]
transition on LONG_CONST to state [55]
transition on FLOAT_CONST to state [54]
transition on variable to state [53]
transition on MINUS to state [52]
transition on PLUSPLUS to state [51]
transition on BITWISE_NOT to state [50]
transition on INT_CONST to state [49]
transition on LPAREN to state [48]
transition on BOOL_CONST to state [47]
transition on MINUSMINUS to state [46]
transition on IDENTIFIER to state [45]
transition on NOT to state [44]
transition on expr to state [220]
transition on SEMICOLON to state [219]
transition on DOUBLE_CONST to state [42]
transition on SIZEOF to state [41]
transition on INPUT to state [6]
transition on STRING_CONST to state [40]

-------------------
lalr_state [13]: {
  [cond_stmt ::= (*) SWITCH LPAREN expr RPAREN OF COLON BEGIN case_part DEFAULT COLON block END , {IDENTIFIER INT LONG FLOAT DOUBLE BOOL CHAR STRING AUTO IF RETURN BREAK CONTINUE SWITCH END FOR REPEAT FOREACH CONST PRINTLN INPUT }]
  [assignment ::= (*) variable DIVIDE_ASSIGN expr , {SEMICOLON }]
  [block_part ::= block_body (*) , {END }]
  [statement ::= (*) loop_stmt , {IDENTIFIER INT LONG FLOAT DOUBLE BOOL CHAR STRING AUTO IF RETURN BREAK CONTINUE SWITCH END FOR REPEAT FOREACH CONST PRINTLN INPUT }]
  [block_part ::= (*) block_body , {END }]
  [variable ::= (*) variable LBRACKET expr RBRACKET , {LBRACKET DOT DIRECT_ASSIGN SUM_ASSIGN DIFF_ASSIGN MULT_ASSIGN DIVIDE_ASSIGN MOD_ASSIGN }]
  [var_dcl ::= (*) CONST typeName array_part_no_val NT$0 const_var_dcl_p SEMICOLON , {IDENTIFIER INT LONG FLOAT DOUBLE BOOL CHAR STRING AUTO IF RETURN BREAK CONTINUE SWITCH END FOR REPEAT FOREACH CONST PRINTLN INPUT }]
  [base_type ::= (*) LONG , {LRBRACKET IDENTIFIER }]
  [loop_stmt ::= (*) FOR LPAREN for_init_part SEMICOLON expr SEMICOLON expr RPAREN block , {IDENTIFIER INT LONG FLOAT DOUBLE BOOL CHAR STRING AUTO IF RETURN BREAK CONTINUE SWITCH END FOR REPEAT FOREACH CONST PRINTLN INPUT }]
  [assignment ::= (*) variable DIRECT_ASSIGN expr , {SEMICOLON }]
  [block_body ::= (*) PRINTLN LPAREN expr RPAREN SEMICOLON , {IDENTIFIER INT LONG FLOAT DOUBLE BOOL CHAR STRING AUTO IF RETURN BREAK CONTINUE SWITCH END FOR REPEAT FOREACH CONST PRINTLN INPUT }]
  [base_type ::= (*) STRING , {LRBRACKET IDENTIFIER }]
  [cond_stmt ::= (*) SWITCH LPAREN expr RPAREN OF COLON BEGIN case_part END , {IDENTIFIER INT LONG FLOAT DOUBLE BOOL CHAR STRING AUTO IF RETURN BREAK CONTINUE SWITCH END FOR REPEAT FOREACH CONST PRINTLN INPUT }]
  [assignment ::= (*) variable MOD_ASSIGN expr , {SEMICOLON }]
  [block_part ::= block_body (*) block_part , {END }]
  [statement ::= (*) RETURN SEMICOLON , {IDENTIFIER INT LONG FLOAT DOUBLE BOOL CHAR STRING AUTO IF RETURN BREAK CONTINUE SWITCH END FOR REPEAT FOREACH CONST PRINTLN INPUT }]
  [block_part ::= (*) block_body block_part , {END }]
  [variable ::= (*) variable DOT IDENTIFIER , {LBRACKET DOT DIRECT_ASSIGN SUM_ASSIGN DIFF_ASSIGN MULT_ASSIGN DIVIDE_ASSIGN MOD_ASSIGN }]
  [base_type ::= (*) FLOAT , {LRBRACKET IDENTIFIER }]
  [loop_stmt ::= (*) FOR LPAREN for_init_part SEMICOLON expr SEMICOLON RPAREN block , {IDENTIFIER INT LONG FLOAT DOUBLE BOOL CHAR STRING AUTO IF RETURN BREAK CONTINUE SWITCH END FOR REPEAT FOREACH CONST PRINTLN INPUT }]
  [assignment ::= (*) variable SUM_ASSIGN expr , {SEMICOLON }]
  [block_body ::= (*) PRINTLN LPAREN RPAREN SEMICOLON , {IDENTIFIER INT LONG FLOAT DOUBLE BOOL CHAR STRING AUTO IF RETURN BREAK CONTINUE SWITCH END FOR REPEAT FOREACH CONST PRINTLN INPUT }]
  [var_dcl ::= (*) AUTO NT$3 const_var_dcl_p SEMICOLON , {IDENTIFIER INT LONG FLOAT DOUBLE BOOL CHAR STRING AUTO IF RETURN BREAK CONTINUE SWITCH END FOR REPEAT FOREACH CONST PRINTLN INPUT }]
  [typeName ::= (*) base_type , {LRBRACKET IDENTIFIER }]
  [method_cal ::= (*) IDENTIFIER LPAREN parameters RPAREN , {SEMICOLON }]
  [statement ::= (*) RETURN expr SEMICOLON , {IDENTIFIER INT LONG FLOAT DOUBLE BOOL CHAR STRING AUTO IF RETURN BREAK CONTINUE SWITCH END FOR REPEAT FOREACH CONST PRINTLN INPUT }]
  [block_body ::= (*) var_dcl , {IDENTIFIER INT LONG FLOAT DOUBLE BOOL CHAR STRING AUTO IF RETURN BREAK CONTINUE SWITCH END FOR REPEAT FOREACH CONST PRINTLN INPUT }]
  [var_dcl ::= (*) typeName array_part_no_val NT$1 var_dcl_p SEMICOLON , {IDENTIFIER INT LONG FLOAT DOUBLE BOOL CHAR STRING AUTO IF RETURN BREAK CONTINUE SWITCH END FOR REPEAT FOREACH CONST PRINTLN INPUT }]
  [base_type ::= (*) DOUBLE , {LRBRACKET IDENTIFIER }]
  [loop_stmt ::= (*) REPEAT block UNTIL LPAREN expr RPAREN SEMICOLON , {IDENTIFIER INT LONG FLOAT DOUBLE BOOL CHAR STRING AUTO IF RETURN BREAK CONTINUE SWITCH END FOR REPEAT FOREACH CONST PRINTLN INPUT }]
  [cond_stmt ::= (*) IF LPAREN expr RPAREN block ELSE block , {IDENTIFIER INT LONG FLOAT DOUBLE BOOL CHAR STRING AUTO IF RETURN BREAK CONTINUE SWITCH END FOR REPEAT FOREACH CONST PRINTLN INPUT }]
  [assignment ::= (*) variable DIFF_ASSIGN expr , {SEMICOLON }]
  [statement ::= (*) assignment SEMICOLON , {IDENTIFIER INT LONG FLOAT DOUBLE BOOL CHAR STRING AUTO IF RETURN BREAK CONTINUE SWITCH END FOR REPEAT FOREACH CONST PRINTLN INPUT }]
  [typeName ::= (*) IDENTIFIER , {LRBRACKET IDENTIFIER }]
  [method_cal ::= (*) INPUT LPAREN typeName RPAREN SEMICOLON , {SEMICOLON }]
  [statement ::= (*) BREAK SEMICOLON , {IDENTIFIER INT LONG FLOAT DOUBLE BOOL CHAR STRING AUTO IF RETURN BREAK CONTINUE SWITCH END FOR REPEAT FOREACH CONST PRINTLN INPUT }]
  [block_body ::= (*) statement , {IDENTIFIER INT LONG FLOAT DOUBLE BOOL CHAR STRING AUTO IF RETURN BREAK CONTINUE SWITCH END FOR REPEAT FOREACH CONST PRINTLN INPUT }]
  [base_type ::= (*) BOOL , {LRBRACKET IDENTIFIER }]
  [loop_stmt ::= (*) FOREACH LPAREN IDENTIFIER IN variable RPAREN block , {IDENTIFIER INT LONG FLOAT DOUBLE BOOL CHAR STRING AUTO IF RETURN BREAK CONTINUE SWITCH END FOR REPEAT FOREACH CONST PRINTLN INPUT }]
  [cond_stmt ::= (*) IF LPAREN expr RPAREN block , {IDENTIFIER INT LONG FLOAT DOUBLE BOOL CHAR STRING AUTO IF RETURN BREAK CONTINUE SWITCH END FOR REPEAT FOREACH CONST PRINTLN INPUT }]
  [assignment ::= (*) variable MULT_ASSIGN expr , {SEMICOLON }]
  [statement ::= (*) cond_stmt , {IDENTIFIER INT LONG FLOAT DOUBLE BOOL CHAR STRING AUTO IF RETURN BREAK CONTINUE SWITCH END FOR REPEAT FOREACH CONST PRINTLN INPUT }]
  [variable ::= (*) IDENTIFIER , {LBRACKET DOT DIRECT_ASSIGN SUM_ASSIGN DIFF_ASSIGN MULT_ASSIGN DIVIDE_ASSIGN MOD_ASSIGN }]
  [base_type ::= (*) INT , {LRBRACKET IDENTIFIER }]
  [loop_stmt ::= (*) FOR LPAREN for_init_part SEMICOLON expr SEMICOLON assignment RPAREN block , {IDENTIFIER INT LONG FLOAT DOUBLE BOOL CHAR STRING AUTO IF RETURN BREAK CONTINUE SWITCH END FOR REPEAT FOREACH CONST PRINTLN INPUT }]
  [method_cal ::= (*) INPUT LPAREN RPAREN SEMICOLON , {SEMICOLON }]
  [statement ::= (*) CONTINUE SEMICOLON , {IDENTIFIER INT LONG FLOAT DOUBLE BOOL CHAR STRING AUTO IF RETURN BREAK CONTINUE SWITCH END FOR REPEAT FOREACH CONST PRINTLN INPUT }]
  [block_body ::= (*) method_cal SEMICOLON , {IDENTIFIER INT LONG FLOAT DOUBLE BOOL CHAR STRING AUTO IF RETURN BREAK CONTINUE SWITCH END FOR REPEAT FOREACH CONST PRINTLN INPUT }]
  [var_dcl ::= (*) CONST AUTO NT$2 const_var_dcl_p SEMICOLON , {IDENTIFIER INT LONG FLOAT DOUBLE BOOL CHAR STRING AUTO IF RETURN BREAK CONTINUE SWITCH END FOR REPEAT FOREACH CONST PRINTLN INPUT }]
  [base_type ::= (*) CHAR , {LRBRACKET IDENTIFIER }]
}
transition on DOUBLE to state [36]
transition on var_dcl to state [35]
transition on REPEAT to state [34]
transition on FOR to state [33]
transition on method_cal to state [32]
transition on BOOL to state [31]
transition on base_type to state [30]
transition on variable to state [29]
transition on CONST to state [28]
transition on cond_stmt to state [27]
transition on assignment to state [26]
transition on BREAK to state [25]
transition on AUTO to state [24]
transition on FOREACH to state [23]
transition on PRINTLN to state [22]
transition on FLOAT to state [21]
transition on loop_stmt to state [20]
transition on STRING to state [19]
transition on block_part to state [218]
transition on typeName to state [17]
transition on IF to state [16]
transition on SWITCH to state [15]
transition on IDENTIFIER to state [14]
transition on block_body to state [13]
transition on RETURN to state [12]
transition on CHAR to state [11]
transition on INT to state [10]
transition on statement to state [9]
transition on CONTINUE to state [8]
transition on LONG to state [7]
transition on INPUT to state [6]

-------------------
lalr_state [14]: {
  [variable ::= IDENTIFIER (*) , {LBRACKET DOT DIRECT_ASSIGN SUM_ASSIGN DIFF_ASSIGN MULT_ASSIGN DIVIDE_ASSIGN MOD_ASSIGN }]
  [typeName ::= IDENTIFIER (*) , {LRBRACKET IDENTIFIER }]
  [method_cal ::= IDENTIFIER (*) LPAREN parameters RPAREN , {SEMICOLON }]
}
transition on LPAREN to state [108]

-------------------
lalr_state [15]: {
  [cond_stmt ::= SWITCH (*) LPAREN expr RPAREN OF COLON BEGIN case_part DEFAULT COLON block END , {IDENTIFIER INT LONG FLOAT DOUBLE BOOL CHAR STRING AUTO IF RETURN BREAK CONTINUE SWITCH END FOR REPEAT FOREACH CONST PRINTLN INPUT }]
  [cond_stmt ::= SWITCH (*) LPAREN expr RPAREN OF COLON BEGIN case_part END , {IDENTIFIER INT LONG FLOAT DOUBLE BOOL CHAR STRING AUTO IF RETURN BREAK CONTINUE SWITCH END FOR REPEAT FOREACH CONST PRINTLN INPUT }]
}
transition on LPAREN to state [201]

-------------------
lalr_state [16]: {
  [cond_stmt ::= IF (*) LPAREN expr RPAREN block , {IDENTIFIER INT LONG FLOAT DOUBLE BOOL CHAR STRING AUTO IF RETURN BREAK CONTINUE SWITCH END FOR REPEAT FOREACH CONST PRINTLN INPUT }]
  [cond_stmt ::= IF (*) LPAREN expr RPAREN block ELSE block , {IDENTIFIER INT LONG FLOAT DOUBLE BOOL CHAR STRING AUTO IF RETURN BREAK CONTINUE SWITCH END FOR REPEAT FOREACH CONST PRINTLN INPUT }]
}
transition on LPAREN to state [195]

-------------------
lalr_state [17]: {
  [array_part_no_val ::= (*) , {IDENTIFIER }]
  [array_part_no_val ::= (*) LRBRACKET array_part_no_val , {IDENTIFIER }]
  [var_dcl ::= typeName (*) array_part_no_val NT$1 var_dcl_p SEMICOLON , {IDENTIFIER INT LONG FLOAT DOUBLE BOOL CHAR STRING AUTO IF RETURN BREAK CONTINUE SWITCH END FOR REPEAT FOREACH CONST PRINTLN INPUT }]
}
transition on LRBRACKET to state [160]
transition on array_part_no_val to state [184]

-------------------
lalr_state [18]: {
  [NT$5 ::= (*) , {END }]
  [block ::= BEGIN NT$4 block_part (*) NT$5 END , {EOF IDENTIFIER INT LONG FLOAT DOUBLE BOOL CHAR STRING AUTO IF ELSE RETURN BREAK CONTINUE SWITCH CASE DEFAULT END FOR REPEAT UNTIL FOREACH CONST PRINTLN INPUT }]
}
transition on NT$5 to state [182]

-------------------
lalr_state [19]: {
  [base_type ::= STRING (*) , {RPAREN LRBRACKET IDENTIFIER }]
}

-------------------
lalr_state [20]: {
  [statement ::= loop_stmt (*) , {IDENTIFIER INT LONG FLOAT DOUBLE BOOL CHAR STRING AUTO IF RETURN BREAK CONTINUE SWITCH END FOR REPEAT FOREACH CONST PRINTLN INPUT }]
}

-------------------
lalr_state [21]: {
  [base_type ::= FLOAT (*) , {RPAREN LRBRACKET IDENTIFIER }]
}

-------------------
lalr_state [22]: {
  [block_body ::= PRINTLN (*) LPAREN expr RPAREN SEMICOLON , {IDENTIFIER INT LONG FLOAT DOUBLE BOOL CHAR STRING AUTO IF RETURN BREAK CONTINUE SWITCH END FOR REPEAT FOREACH CONST PRINTLN INPUT }]
  [block_body ::= PRINTLN (*) LPAREN RPAREN SEMICOLON , {IDENTIFIER INT LONG FLOAT DOUBLE BOOL CHAR STRING AUTO IF RETURN BREAK CONTINUE SWITCH END FOR REPEAT FOREACH CONST PRINTLN INPUT }]
}
transition on LPAREN to state [176]

-------------------
lalr_state [23]: {
  [loop_stmt ::= FOREACH (*) LPAREN IDENTIFIER IN variable RPAREN block , {IDENTIFIER INT LONG FLOAT DOUBLE BOOL CHAR STRING AUTO IF RETURN BREAK CONTINUE SWITCH END FOR REPEAT FOREACH CONST PRINTLN INPUT }]
}
transition on LPAREN to state [170]

-------------------
lalr_state [24]: {
  [var_dcl ::= AUTO (*) NT$3 const_var_dcl_p SEMICOLON , {IDENTIFIER INT LONG FLOAT DOUBLE BOOL CHAR STRING AUTO IF RETURN BREAK CONTINUE SWITCH END FOR REPEAT FOREACH CONST PRINTLN INPUT }]
  [NT$3 ::= (*) , {IDENTIFIER }]
}
transition on NT$3 to state [167]

-------------------
lalr_state [25]: {
  [statement ::= BREAK (*) SEMICOLON , {IDENTIFIER INT LONG FLOAT DOUBLE BOOL CHAR STRING AUTO IF RETURN BREAK CONTINUE SWITCH END FOR REPEAT FOREACH CONST PRINTLN INPUT }]
}
transition on SEMICOLON to state [166]

-------------------
lalr_state [26]: {
  [statement ::= assignment (*) SEMICOLON , {IDENTIFIER INT LONG FLOAT DOUBLE BOOL CHAR STRING AUTO IF RETURN BREAK CONTINUE SWITCH END FOR REPEAT FOREACH CONST PRINTLN INPUT }]
}
transition on SEMICOLON to state [165]

-------------------
lalr_state [27]: {
  [statement ::= cond_stmt (*) , {IDENTIFIER INT LONG FLOAT DOUBLE BOOL CHAR STRING AUTO IF RETURN BREAK CONTINUE SWITCH END FOR REPEAT FOREACH CONST PRINTLN INPUT }]
}

-------------------
lalr_state [28]: {
  [base_type ::= (*) BOOL , {LRBRACKET IDENTIFIER }]
  [base_type ::= (*) LONG , {LRBRACKET IDENTIFIER }]
  [base_type ::= (*) STRING , {LRBRACKET IDENTIFIER }]
  [base_type ::= (*) DOUBLE , {LRBRACKET IDENTIFIER }]
  [base_type ::= (*) INT , {LRBRACKET IDENTIFIER }]
  [var_dcl ::= CONST (*) AUTO NT$2 const_var_dcl_p SEMICOLON , {IDENTIFIER INT LONG FLOAT DOUBLE BOOL CHAR STRING AUTO IF RETURN BREAK CONTINUE SWITCH END FOR REPEAT FOREACH CONST PRINTLN INPUT }]
  [typeName ::= (*) IDENTIFIER , {LRBRACKET IDENTIFIER }]
  [base_type ::= (*) CHAR , {LRBRACKET IDENTIFIER }]
  [base_type ::= (*) FLOAT , {LRBRACKET IDENTIFIER }]
  [var_dcl ::= CONST (*) typeName array_part_no_val NT$0 const_var_dcl_p SEMICOLON , {IDENTIFIER INT LONG FLOAT DOUBLE BOOL CHAR STRING AUTO IF RETURN BREAK CONTINUE SWITCH END FOR REPEAT FOREACH CONST PRINTLN INPUT }]
  [typeName ::= (*) base_type , {LRBRACKET IDENTIFIER }]
}
transition on CHAR to state [11]
transition on FLOAT to state [21]
transition on AUTO to state [150]
transition on base_type to state [30]
transition on IDENTIFIER to state [118]
transition on typeName to state [149]
transition on DOUBLE to state [36]
transition on STRING to state [19]
transition on BOOL to state [31]
transition on LONG to state [7]
transition on INT to state [10]

-------------------
lalr_state [29]: {
  [assignment ::= variable (*) MOD_ASSIGN expr , {SEMICOLON }]
  [assignment ::= variable (*) DIFF_ASSIGN expr , {SEMICOLON }]
  [assignment ::= variable (*) DIVIDE_ASSIGN expr , {SEMICOLON }]
  [assignment ::= variable (*) SUM_ASSIGN expr , {SEMICOLON }]
  [variable ::= variable (*) DOT IDENTIFIER , {LBRACKET DOT DIRECT_ASSIGN SUM_ASSIGN DIFF_ASSIGN MULT_ASSIGN DIVIDE_ASSIGN MOD_ASSIGN }]
  [assignment ::= variable (*) MULT_ASSIGN expr , {SEMICOLON }]
  [assignment ::= variable (*) DIRECT_ASSIGN expr , {SEMICOLON }]
  [variable ::= variable (*) LBRACKET expr RBRACKET , {LBRACKET DOT DIRECT_ASSIGN SUM_ASSIGN DIFF_ASSIGN MULT_ASSIGN DIVIDE_ASSIGN MOD_ASSIGN }]
}
transition on DOT to state [62]
transition on MOD_ASSIGN to state [134]
transition on LBRACKET to state [60]
transition on DIFF_ASSIGN to state [131]
transition on SUM_ASSIGN to state [132]
transition on MULT_ASSIGN to state [136]
transition on DIRECT_ASSIGN to state [135]
transition on DIVIDE_ASSIGN to state [133]

-------------------
lalr_state [30]: {
  [typeName ::= base_type (*) , {RPAREN LRBRACKET IDENTIFIER }]
}

-------------------
lalr_state [31]: {
  [base_type ::= BOOL (*) , {RPAREN LRBRACKET IDENTIFIER }]
}

-------------------
lalr_state [32]: {
  [block_body ::= method_cal (*) SEMICOLON , {IDENTIFIER INT LONG FLOAT DOUBLE BOOL CHAR STRING AUTO IF RETURN BREAK CONTINUE SWITCH END FOR REPEAT FOREACH CONST PRINTLN INPUT }]
}
transition on SEMICOLON to state [148]

-------------------
lalr_state [33]: {
  [loop_stmt ::= FOR (*) LPAREN for_init_part SEMICOLON expr SEMICOLON expr RPAREN block , {IDENTIFIER INT LONG FLOAT DOUBLE BOOL CHAR STRING AUTO IF RETURN BREAK CONTINUE SWITCH END FOR REPEAT FOREACH CONST PRINTLN INPUT }]
  [loop_stmt ::= FOR (*) LPAREN for_init_part SEMICOLON expr SEMICOLON assignment RPAREN block , {IDENTIFIER INT LONG FLOAT DOUBLE BOOL CHAR STRING AUTO IF RETURN BREAK CONTINUE SWITCH END FOR REPEAT FOREACH CONST PRINTLN INPUT }]
  [loop_stmt ::= FOR (*) LPAREN for_init_part SEMICOLON expr SEMICOLON RPAREN block , {IDENTIFIER INT LONG FLOAT DOUBLE BOOL CHAR STRING AUTO IF RETURN BREAK CONTINUE SWITCH END FOR REPEAT FOREACH CONST PRINTLN INPUT }]
}
transition on LPAREN to state [121]

-------------------
lalr_state [34]: {
  [block ::= (*) BEGIN END , {UNTIL }]
  [loop_stmt ::= REPEAT (*) block UNTIL LPAREN expr RPAREN SEMICOLON , {IDENTIFIER INT LONG FLOAT DOUBLE BOOL CHAR STRING AUTO IF RETURN BREAK CONTINUE SWITCH END FOR REPEAT FOREACH CONST PRINTLN INPUT }]
  [block ::= (*) BEGIN NT$4 block_part NT$5 END , {UNTIL }]
}
transition on block to state [37]
transition on BEGIN to state [2]

-------------------
lalr_state [35]: {
  [block_body ::= var_dcl (*) , {IDENTIFIER INT LONG FLOAT DOUBLE BOOL CHAR STRING AUTO IF RETURN BREAK CONTINUE SWITCH END FOR REPEAT FOREACH CONST PRINTLN INPUT }]
}

-------------------
lalr_state [36]: {
  [base_type ::= DOUBLE (*) , {RPAREN LRBRACKET IDENTIFIER }]
}

-------------------
lalr_state [37]: {
  [loop_stmt ::= REPEAT block (*) UNTIL LPAREN expr RPAREN SEMICOLON , {IDENTIFIER INT LONG FLOAT DOUBLE BOOL CHAR STRING AUTO IF RETURN BREAK CONTINUE SWITCH END FOR REPEAT FOREACH CONST PRINTLN INPUT }]
}
transition on UNTIL to state [38]

-------------------
lalr_state [38]: {
  [loop_stmt ::= REPEAT block UNTIL (*) LPAREN expr RPAREN SEMICOLON , {IDENTIFIER INT LONG FLOAT DOUBLE BOOL CHAR STRING AUTO IF RETURN BREAK CONTINUE SWITCH END FOR REPEAT FOREACH CONST PRINTLN INPUT }]
}
transition on LPAREN to state [39]

-------------------
lalr_state [39]: {
  [expr ::= (*) expr BITWISE_OR expr , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [variable ::= (*) variable LBRACKET expr RBRACKET , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN LBRACKET DOT PLUSPLUS MINUSMINUS }]
  [expr ::= (*) variable PLUSPLUS , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [expr ::= (*) expr GREATER expr , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [expr ::= (*) expr DIVIDE expr , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [const_val ::= (*) FLOAT_CONST , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [expr ::= (*) const_val , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [expr ::= (*) variable , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [expr ::= (*) expr EQUAL expr , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [variable ::= (*) variable DOT IDENTIFIER , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN LBRACKET DOT PLUSPLUS MINUSMINUS }]
  [expr ::= (*) method_cal , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [expr ::= (*) expr LESS expr , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [expr ::= (*) expr MOD expr , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [const_val ::= (*) CHAR_CONST , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [expr ::= (*) SIZEOF LPAREN typeName RPAREN , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [expr ::= (*) MINUSMINUS variable , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [expr ::= (*) expr NOT_EQUAL expr , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [expr ::= (*) expr PLUS expr , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [method_cal ::= (*) IDENTIFIER LPAREN parameters RPAREN , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [const_val ::= (*) INT_CONST , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [loop_stmt ::= REPEAT block UNTIL LPAREN (*) expr RPAREN SEMICOLON , {IDENTIFIER INT LONG FLOAT DOUBLE BOOL CHAR STRING AUTO IF RETURN BREAK CONTINUE SWITCH END FOR REPEAT FOREACH CONST PRINTLN INPUT }]
  [expr ::= (*) MINUS expr , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [expr ::= (*) expr AND expr , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [expr ::= (*) expr BITWISE_AND expr , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [const_val ::= (*) BOOL_CONST , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [expr ::= (*) LPAREN base_type RPAREN expr , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [expr ::= (*) PLUSPLUS variable , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [expr ::= (*) expr GREATER_EQUAL expr , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [expr ::= (*) expr MINUS expr , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [method_cal ::= (*) INPUT LPAREN typeName RPAREN SEMICOLON , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [const_val ::= (*) LONG_CONST , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [expr ::= (*) BITWISE_NOT expr , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [expr ::= (*) expr OR expr , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [expr ::= (*) expr BITWISE_XOR expr , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [const_val ::= (*) STRING_CONST , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [variable ::= (*) IDENTIFIER , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN LBRACKET DOT PLUSPLUS MINUSMINUS }]
  [expr ::= (*) variable MINUSMINUS , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [expr ::= (*) expr LESS_EQUAL expr , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [expr ::= (*) expr MULTIPLY expr , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [method_cal ::= (*) INPUT LPAREN RPAREN SEMICOLON , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [const_val ::= (*) DOUBLE_CONST , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [expr ::= (*) NOT expr , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [expr ::= (*) LPAREN expr RPAREN , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
}
transition on CHAR_CONST to state [58]
transition on method_cal to state [57]
transition on const_val to state [56]
transition on LONG_CONST to state [55]
transition on FLOAT_CONST to state [54]
transition on variable to state [53]
transition on MINUS to state [52]
transition on PLUSPLUS to state [51]
transition on BITWISE_NOT to state [50]
transition on INT_CONST to state [49]
transition on LPAREN to state [48]
transition on BOOL_CONST to state [47]
transition on MINUSMINUS to state [46]
transition on IDENTIFIER to state [45]
transition on NOT to state [44]
transition on expr to state [43]
transition on DOUBLE_CONST to state [42]
transition on SIZEOF to state [41]
transition on INPUT to state [6]
transition on STRING_CONST to state [40]

-------------------
lalr_state [40]: {
  [const_val ::= STRING_CONST (*) , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
}

-------------------
lalr_state [41]: {
  [expr ::= SIZEOF (*) LPAREN typeName RPAREN , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
}
transition on LPAREN to state [117]

-------------------
lalr_state [42]: {
  [const_val ::= DOUBLE_CONST (*) , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
}

-------------------
lalr_state [43]: {
  [expr ::= expr (*) BITWISE_OR expr , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [expr ::= expr (*) MOD expr , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [expr ::= expr (*) MINUS expr , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [expr ::= expr (*) OR expr , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [expr ::= expr (*) GREATER expr , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [expr ::= expr (*) NOT_EQUAL expr , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [expr ::= expr (*) BITWISE_XOR expr , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [expr ::= expr (*) DIVIDE expr , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [expr ::= expr (*) PLUS expr , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [expr ::= expr (*) AND expr , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [expr ::= expr (*) LESS_EQUAL expr , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [loop_stmt ::= REPEAT block UNTIL LPAREN expr (*) RPAREN SEMICOLON , {IDENTIFIER INT LONG FLOAT DOUBLE BOOL CHAR STRING AUTO IF RETURN BREAK CONTINUE SWITCH END FOR REPEAT FOREACH CONST PRINTLN INPUT }]
  [expr ::= expr (*) EQUAL expr , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [expr ::= expr (*) BITWISE_AND expr , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [expr ::= expr (*) MULTIPLY expr , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [expr ::= expr (*) LESS expr , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [expr ::= expr (*) GREATER_EQUAL expr , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
}
transition on OR to state [81]
transition on BITWISE_XOR to state [80]
transition on BITWISE_AND to state [79]
transition on GREATER_EQUAL to state [78]
transition on RPAREN to state [115]
transition on NOT_EQUAL to state [77]
transition on LESS to state [76]
transition on LESS_EQUAL to state [75]
transition on BITWISE_OR to state [73]
transition on PLUS to state [72]
transition on EQUAL to state [71]
transition on GREATER to state [70]
transition on MOD to state [69]
transition on MULTIPLY to state [68]
transition on DIVIDE to state [67]
transition on MINUS to state [66]
transition on AND to state [65]

-------------------
lalr_state [44]: {
  [expr ::= (*) expr BITWISE_OR expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [variable ::= (*) variable LBRACKET expr RBRACKET , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN LBRACKET RBRACKET DOT COMMA PLUSPLUS MINUSMINUS }]
  [expr ::= (*) variable PLUSPLUS , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) expr GREATER expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) expr DIVIDE expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [const_val ::= (*) FLOAT_CONST , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) const_val , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) variable , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) expr EQUAL expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [variable ::= (*) variable DOT IDENTIFIER , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN LBRACKET RBRACKET DOT COMMA PLUSPLUS MINUSMINUS }]
  [expr ::= (*) method_cal , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) expr LESS expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) expr MOD expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [const_val ::= (*) CHAR_CONST , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) SIZEOF LPAREN typeName RPAREN , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) MINUSMINUS variable , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) expr NOT_EQUAL expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) expr PLUS expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [method_cal ::= (*) IDENTIFIER LPAREN parameters RPAREN , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [const_val ::= (*) INT_CONST , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) MINUS expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) expr AND expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) expr BITWISE_AND expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [const_val ::= (*) BOOL_CONST , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) LPAREN base_type RPAREN expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) PLUSPLUS variable , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) expr GREATER_EQUAL expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) expr MINUS expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [method_cal ::= (*) INPUT LPAREN typeName RPAREN SEMICOLON , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [const_val ::= (*) LONG_CONST , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) BITWISE_NOT expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) expr OR expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) expr BITWISE_XOR expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [const_val ::= (*) STRING_CONST , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [variable ::= (*) IDENTIFIER , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN LBRACKET RBRACKET DOT COMMA PLUSPLUS MINUSMINUS }]
  [expr ::= (*) variable MINUSMINUS , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) expr LESS_EQUAL expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) expr MULTIPLY expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [method_cal ::= (*) INPUT LPAREN RPAREN SEMICOLON , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [const_val ::= (*) DOUBLE_CONST , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= NOT (*) expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) NOT expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) LPAREN expr RPAREN , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
}
transition on CHAR_CONST to state [58]
transition on method_cal to state [57]
transition on const_val to state [56]
transition on LONG_CONST to state [55]
transition on FLOAT_CONST to state [54]
transition on variable to state [53]
transition on MINUS to state [52]
transition on PLUSPLUS to state [51]
transition on BITWISE_NOT to state [50]
transition on INT_CONST to state [49]
transition on LPAREN to state [48]
transition on BOOL_CONST to state [47]
transition on MINUSMINUS to state [46]
transition on IDENTIFIER to state [45]
transition on NOT to state [44]
transition on expr to state [114]
transition on DOUBLE_CONST to state [42]
transition on SIZEOF to state [41]
transition on INPUT to state [6]
transition on STRING_CONST to state [40]

-------------------
lalr_state [45]: {
  [variable ::= IDENTIFIER (*) , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN LBRACKET RBRACKET DOT COMMA PLUSPLUS MINUSMINUS DIRECT_ASSIGN SUM_ASSIGN DIFF_ASSIGN MULT_ASSIGN DIVIDE_ASSIGN MOD_ASSIGN }]
  [method_cal ::= IDENTIFIER (*) LPAREN parameters RPAREN , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
}
transition on LPAREN to state [108]

-------------------
lalr_state [46]: {
  [variable ::= (*) variable LBRACKET expr RBRACKET , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN LBRACKET RBRACKET DOT COMMA }]
  [variable ::= (*) IDENTIFIER , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN LBRACKET RBRACKET DOT COMMA }]
  [expr ::= MINUSMINUS (*) variable , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [variable ::= (*) variable DOT IDENTIFIER , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN LBRACKET RBRACKET DOT COMMA }]
}
transition on IDENTIFIER to state [100]
transition on variable to state [107]

-------------------
lalr_state [47]: {
  [const_val ::= BOOL_CONST (*) , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
}

-------------------
lalr_state [48]: {
  [expr ::= (*) expr BITWISE_OR expr , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [variable ::= (*) variable LBRACKET expr RBRACKET , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN LBRACKET DOT PLUSPLUS MINUSMINUS }]
  [base_type ::= (*) LONG , {RPAREN }]
  [expr ::= (*) variable PLUSPLUS , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [expr ::= (*) expr GREATER expr , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [expr ::= (*) expr DIVIDE expr , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [const_val ::= (*) FLOAT_CONST , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [base_type ::= (*) STRING , {RPAREN }]
  [expr ::= (*) const_val , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [expr ::= (*) variable , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [expr ::= (*) expr EQUAL expr , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [variable ::= (*) variable DOT IDENTIFIER , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN LBRACKET DOT PLUSPLUS MINUSMINUS }]
  [base_type ::= (*) FLOAT , {RPAREN }]
  [expr ::= (*) method_cal , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [expr ::= (*) expr LESS expr , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [expr ::= (*) expr MOD expr , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [const_val ::= (*) CHAR_CONST , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [expr ::= (*) SIZEOF LPAREN typeName RPAREN , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [expr ::= (*) MINUSMINUS variable , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [expr ::= (*) expr NOT_EQUAL expr , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [expr ::= (*) expr PLUS expr , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [method_cal ::= (*) IDENTIFIER LPAREN parameters RPAREN , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [const_val ::= (*) INT_CONST , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [base_type ::= (*) DOUBLE , {RPAREN }]
  [expr ::= (*) MINUS expr , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [expr ::= (*) expr AND expr , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [expr ::= (*) expr BITWISE_AND expr , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [const_val ::= (*) BOOL_CONST , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [expr ::= LPAREN (*) base_type RPAREN expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) LPAREN base_type RPAREN expr , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [expr ::= (*) PLUSPLUS variable , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [expr ::= (*) expr GREATER_EQUAL expr , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [expr ::= (*) expr MINUS expr , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [method_cal ::= (*) INPUT LPAREN typeName RPAREN SEMICOLON , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [const_val ::= (*) LONG_CONST , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [base_type ::= (*) BOOL , {RPAREN }]
  [expr ::= (*) BITWISE_NOT expr , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [expr ::= (*) expr OR expr , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [expr ::= (*) expr BITWISE_XOR expr , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [const_val ::= (*) STRING_CONST , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [variable ::= (*) IDENTIFIER , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN LBRACKET DOT PLUSPLUS MINUSMINUS }]
  [base_type ::= (*) INT , {RPAREN }]
  [expr ::= (*) variable MINUSMINUS , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [expr ::= (*) expr LESS_EQUAL expr , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [expr ::= (*) expr MULTIPLY expr , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [method_cal ::= (*) INPUT LPAREN RPAREN SEMICOLON , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [const_val ::= (*) DOUBLE_CONST , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [base_type ::= (*) CHAR , {RPAREN }]
  [expr ::= LPAREN (*) expr RPAREN , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) NOT expr , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [expr ::= (*) LPAREN expr RPAREN , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
}
transition on DOUBLE to state [36]
transition on CHAR_CONST to state [58]
transition on method_cal to state [57]
transition on const_val to state [56]
transition on BOOL to state [31]
transition on base_type to state [103]
transition on LONG_CONST to state [55]
transition on FLOAT_CONST to state [54]
transition on variable to state [53]
transition on MINUS to state [52]
transition on PLUSPLUS to state [51]
transition on BITWISE_NOT to state [50]
transition on FLOAT to state [21]
transition on STRING to state [19]
transition on INT_CONST to state [49]
transition on LPAREN to state [48]
transition on BOOL_CONST to state [47]
transition on MINUSMINUS to state [46]
transition on IDENTIFIER to state [45]
transition on NOT to state [44]
transition on CHAR to state [11]
transition on INT to state [10]
transition on expr to state [102]
transition on DOUBLE_CONST to state [42]
transition on LONG to state [7]
transition on SIZEOF to state [41]
transition on INPUT to state [6]
transition on STRING_CONST to state [40]

-------------------
lalr_state [49]: {
  [const_val ::= INT_CONST (*) , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
}

-------------------
lalr_state [50]: {
  [expr ::= (*) expr BITWISE_OR expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [variable ::= (*) variable LBRACKET expr RBRACKET , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN LBRACKET RBRACKET DOT COMMA PLUSPLUS MINUSMINUS }]
  [expr ::= (*) variable PLUSPLUS , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) expr GREATER expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) expr DIVIDE expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [const_val ::= (*) FLOAT_CONST , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) const_val , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) variable , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) expr EQUAL expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [variable ::= (*) variable DOT IDENTIFIER , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN LBRACKET RBRACKET DOT COMMA PLUSPLUS MINUSMINUS }]
  [expr ::= (*) method_cal , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) expr LESS expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) expr MOD expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [const_val ::= (*) CHAR_CONST , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) SIZEOF LPAREN typeName RPAREN , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) MINUSMINUS variable , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) expr NOT_EQUAL expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) expr PLUS expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [method_cal ::= (*) IDENTIFIER LPAREN parameters RPAREN , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [const_val ::= (*) INT_CONST , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) MINUS expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) expr AND expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) expr BITWISE_AND expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [const_val ::= (*) BOOL_CONST , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) LPAREN base_type RPAREN expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) PLUSPLUS variable , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) expr GREATER_EQUAL expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) expr MINUS expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [method_cal ::= (*) INPUT LPAREN typeName RPAREN SEMICOLON , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [const_val ::= (*) LONG_CONST , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= BITWISE_NOT (*) expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) BITWISE_NOT expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) expr OR expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) expr BITWISE_XOR expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [const_val ::= (*) STRING_CONST , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [variable ::= (*) IDENTIFIER , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN LBRACKET RBRACKET DOT COMMA PLUSPLUS MINUSMINUS }]
  [expr ::= (*) variable MINUSMINUS , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) expr LESS_EQUAL expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) expr MULTIPLY expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [method_cal ::= (*) INPUT LPAREN RPAREN SEMICOLON , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [const_val ::= (*) DOUBLE_CONST , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) NOT expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) LPAREN expr RPAREN , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
}
transition on CHAR_CONST to state [58]
transition on method_cal to state [57]
transition on const_val to state [56]
transition on LONG_CONST to state [55]
transition on FLOAT_CONST to state [54]
transition on variable to state [53]
transition on MINUS to state [52]
transition on PLUSPLUS to state [51]
transition on BITWISE_NOT to state [50]
transition on INT_CONST to state [49]
transition on LPAREN to state [48]
transition on BOOL_CONST to state [47]
transition on MINUSMINUS to state [46]
transition on IDENTIFIER to state [45]
transition on NOT to state [44]
transition on expr to state [101]
transition on DOUBLE_CONST to state [42]
transition on SIZEOF to state [41]
transition on INPUT to state [6]
transition on STRING_CONST to state [40]

-------------------
lalr_state [51]: {
  [variable ::= (*) variable LBRACKET expr RBRACKET , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN LBRACKET RBRACKET DOT COMMA }]
  [expr ::= PLUSPLUS (*) variable , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [variable ::= (*) IDENTIFIER , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN LBRACKET RBRACKET DOT COMMA }]
  [variable ::= (*) variable DOT IDENTIFIER , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN LBRACKET RBRACKET DOT COMMA }]
}
transition on IDENTIFIER to state [100]
transition on variable to state [99]

-------------------
lalr_state [52]: {
  [expr ::= (*) expr BITWISE_OR expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [variable ::= (*) variable LBRACKET expr RBRACKET , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN LBRACKET RBRACKET DOT COMMA PLUSPLUS MINUSMINUS }]
  [expr ::= (*) variable PLUSPLUS , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) expr GREATER expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) expr DIVIDE expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [const_val ::= (*) FLOAT_CONST , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) const_val , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) variable , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) expr EQUAL expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [variable ::= (*) variable DOT IDENTIFIER , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN LBRACKET RBRACKET DOT COMMA PLUSPLUS MINUSMINUS }]
  [expr ::= (*) method_cal , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) expr LESS expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) expr MOD expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [const_val ::= (*) CHAR_CONST , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) SIZEOF LPAREN typeName RPAREN , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) MINUSMINUS variable , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) expr NOT_EQUAL expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) expr PLUS expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [method_cal ::= (*) IDENTIFIER LPAREN parameters RPAREN , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [const_val ::= (*) INT_CONST , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= MINUS (*) expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) MINUS expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) expr AND expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) expr BITWISE_AND expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [const_val ::= (*) BOOL_CONST , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) LPAREN base_type RPAREN expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) PLUSPLUS variable , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) expr GREATER_EQUAL expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) expr MINUS expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [method_cal ::= (*) INPUT LPAREN typeName RPAREN SEMICOLON , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [const_val ::= (*) LONG_CONST , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) BITWISE_NOT expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) expr OR expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) expr BITWISE_XOR expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [const_val ::= (*) STRING_CONST , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [variable ::= (*) IDENTIFIER , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN LBRACKET RBRACKET DOT COMMA PLUSPLUS MINUSMINUS }]
  [expr ::= (*) variable MINUSMINUS , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) expr LESS_EQUAL expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) expr MULTIPLY expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [method_cal ::= (*) INPUT LPAREN RPAREN SEMICOLON , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [const_val ::= (*) DOUBLE_CONST , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) NOT expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) LPAREN expr RPAREN , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
}
transition on CHAR_CONST to state [58]
transition on method_cal to state [57]
transition on const_val to state [56]
transition on LONG_CONST to state [55]
transition on FLOAT_CONST to state [54]
transition on variable to state [53]
transition on MINUS to state [52]
transition on PLUSPLUS to state [51]
transition on BITWISE_NOT to state [50]
transition on INT_CONST to state [49]
transition on LPAREN to state [48]
transition on BOOL_CONST to state [47]
transition on MINUSMINUS to state [46]
transition on IDENTIFIER to state [45]
transition on NOT to state [44]
transition on expr to state [98]
transition on DOUBLE_CONST to state [42]
transition on SIZEOF to state [41]
transition on INPUT to state [6]
transition on STRING_CONST to state [40]

-------------------
lalr_state [53]: {
  [expr ::= variable (*) PLUSPLUS , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [variable ::= variable (*) DOT IDENTIFIER , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN LBRACKET RBRACKET DOT COMMA PLUSPLUS MINUSMINUS }]
  [expr ::= variable (*) MINUSMINUS , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= variable (*) , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [variable ::= variable (*) LBRACKET expr RBRACKET , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN LBRACKET RBRACKET DOT COMMA PLUSPLUS MINUSMINUS }]
}
transition on DOT to state [62]
transition on PLUSPLUS to state [61]
transition on LBRACKET to state [60]
transition on MINUSMINUS to state [59]

-------------------
lalr_state [54]: {
  [const_val ::= FLOAT_CONST (*) , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
}

-------------------
lalr_state [55]: {
  [const_val ::= LONG_CONST (*) , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
}

-------------------
lalr_state [56]: {
  [expr ::= const_val (*) , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
}

-------------------
lalr_state [57]: {
  [expr ::= method_cal (*) , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
}

-------------------
lalr_state [58]: {
  [const_val ::= CHAR_CONST (*) , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
}

-------------------
lalr_state [59]: {
  [expr ::= variable MINUSMINUS (*) , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
}

-------------------
lalr_state [60]: {
  [expr ::= (*) expr BITWISE_OR expr , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RBRACKET }]
  [variable ::= variable LBRACKET (*) expr RBRACKET , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN LBRACKET RBRACKET DOT COMMA PLUSPLUS MINUSMINUS DIRECT_ASSIGN SUM_ASSIGN DIFF_ASSIGN MULT_ASSIGN DIVIDE_ASSIGN MOD_ASSIGN }]
  [variable ::= (*) variable LBRACKET expr RBRACKET , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR LBRACKET RBRACKET DOT PLUSPLUS MINUSMINUS }]
  [expr ::= (*) variable PLUSPLUS , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RBRACKET }]
  [expr ::= (*) expr GREATER expr , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RBRACKET }]
  [expr ::= (*) expr DIVIDE expr , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RBRACKET }]
  [const_val ::= (*) FLOAT_CONST , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RBRACKET }]
  [expr ::= (*) const_val , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RBRACKET }]
  [expr ::= (*) variable , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RBRACKET }]
  [expr ::= (*) expr EQUAL expr , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RBRACKET }]
  [variable ::= (*) variable DOT IDENTIFIER , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR LBRACKET RBRACKET DOT PLUSPLUS MINUSMINUS }]
  [expr ::= (*) method_cal , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RBRACKET }]
  [expr ::= (*) expr LESS expr , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RBRACKET }]
  [expr ::= (*) expr MOD expr , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RBRACKET }]
  [const_val ::= (*) CHAR_CONST , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RBRACKET }]
  [expr ::= (*) SIZEOF LPAREN typeName RPAREN , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RBRACKET }]
  [expr ::= (*) MINUSMINUS variable , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RBRACKET }]
  [expr ::= (*) expr NOT_EQUAL expr , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RBRACKET }]
  [expr ::= (*) expr PLUS expr , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RBRACKET }]
  [method_cal ::= (*) IDENTIFIER LPAREN parameters RPAREN , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RBRACKET }]
  [const_val ::= (*) INT_CONST , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RBRACKET }]
  [expr ::= (*) MINUS expr , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RBRACKET }]
  [expr ::= (*) expr AND expr , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RBRACKET }]
  [expr ::= (*) expr BITWISE_AND expr , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RBRACKET }]
  [const_val ::= (*) BOOL_CONST , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RBRACKET }]
  [expr ::= (*) LPAREN base_type RPAREN expr , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RBRACKET }]
  [expr ::= (*) PLUSPLUS variable , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RBRACKET }]
  [expr ::= (*) expr GREATER_EQUAL expr , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RBRACKET }]
  [expr ::= (*) expr MINUS expr , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RBRACKET }]
  [method_cal ::= (*) INPUT LPAREN typeName RPAREN SEMICOLON , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RBRACKET }]
  [const_val ::= (*) LONG_CONST , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RBRACKET }]
  [expr ::= (*) BITWISE_NOT expr , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RBRACKET }]
  [expr ::= (*) expr OR expr , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RBRACKET }]
  [expr ::= (*) expr BITWISE_XOR expr , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RBRACKET }]
  [const_val ::= (*) STRING_CONST , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RBRACKET }]
  [variable ::= (*) IDENTIFIER , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR LBRACKET RBRACKET DOT PLUSPLUS MINUSMINUS }]
  [expr ::= (*) variable MINUSMINUS , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RBRACKET }]
  [expr ::= (*) expr LESS_EQUAL expr , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RBRACKET }]
  [expr ::= (*) expr MULTIPLY expr , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RBRACKET }]
  [method_cal ::= (*) INPUT LPAREN RPAREN SEMICOLON , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RBRACKET }]
  [const_val ::= (*) DOUBLE_CONST , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RBRACKET }]
  [expr ::= (*) NOT expr , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RBRACKET }]
  [expr ::= (*) LPAREN expr RPAREN , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RBRACKET }]
}
transition on CHAR_CONST to state [58]
transition on method_cal to state [57]
transition on const_val to state [56]
transition on LONG_CONST to state [55]
transition on FLOAT_CONST to state [54]
transition on variable to state [53]
transition on MINUS to state [52]
transition on PLUSPLUS to state [51]
transition on BITWISE_NOT to state [50]
transition on INT_CONST to state [49]
transition on LPAREN to state [48]
transition on BOOL_CONST to state [47]
transition on MINUSMINUS to state [46]
transition on IDENTIFIER to state [45]
transition on NOT to state [44]
transition on expr to state [64]
transition on DOUBLE_CONST to state [42]
transition on SIZEOF to state [41]
transition on INPUT to state [6]
transition on STRING_CONST to state [40]

-------------------
lalr_state [61]: {
  [expr ::= variable PLUSPLUS (*) , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
}

-------------------
lalr_state [62]: {
  [variable ::= variable DOT (*) IDENTIFIER , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN LBRACKET RBRACKET DOT COMMA PLUSPLUS MINUSMINUS DIRECT_ASSIGN SUM_ASSIGN DIFF_ASSIGN MULT_ASSIGN DIVIDE_ASSIGN MOD_ASSIGN }]
}
transition on IDENTIFIER to state [63]

-------------------
lalr_state [63]: {
  [variable ::= variable DOT IDENTIFIER (*) , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN LBRACKET RBRACKET DOT COMMA PLUSPLUS MINUSMINUS DIRECT_ASSIGN SUM_ASSIGN DIFF_ASSIGN MULT_ASSIGN DIVIDE_ASSIGN MOD_ASSIGN }]
}

-------------------
lalr_state [64]: {
  [expr ::= expr (*) BITWISE_OR expr , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RBRACKET }]
  [expr ::= expr (*) MOD expr , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RBRACKET }]
  [expr ::= expr (*) MINUS expr , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RBRACKET }]
  [expr ::= expr (*) OR expr , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RBRACKET }]
  [expr ::= expr (*) GREATER expr , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RBRACKET }]
  [expr ::= expr (*) NOT_EQUAL expr , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RBRACKET }]
  [expr ::= expr (*) BITWISE_XOR expr , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RBRACKET }]
  [expr ::= expr (*) DIVIDE expr , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RBRACKET }]
  [expr ::= expr (*) PLUS expr , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RBRACKET }]
  [expr ::= expr (*) AND expr , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RBRACKET }]
  [expr ::= expr (*) LESS_EQUAL expr , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RBRACKET }]
  [expr ::= expr (*) EQUAL expr , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RBRACKET }]
  [expr ::= expr (*) BITWISE_AND expr , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RBRACKET }]
  [expr ::= expr (*) MULTIPLY expr , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RBRACKET }]
  [variable ::= variable LBRACKET expr (*) RBRACKET , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN LBRACKET RBRACKET DOT COMMA PLUSPLUS MINUSMINUS DIRECT_ASSIGN SUM_ASSIGN DIFF_ASSIGN MULT_ASSIGN DIVIDE_ASSIGN MOD_ASSIGN }]
  [expr ::= expr (*) LESS expr , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RBRACKET }]
  [expr ::= expr (*) GREATER_EQUAL expr , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RBRACKET }]
}
transition on OR to state [81]
transition on BITWISE_XOR to state [80]
transition on BITWISE_AND to state [79]
transition on GREATER_EQUAL to state [78]
transition on NOT_EQUAL to state [77]
transition on LESS to state [76]
transition on LESS_EQUAL to state [75]
transition on RBRACKET to state [74]
transition on BITWISE_OR to state [73]
transition on PLUS to state [72]
transition on EQUAL to state [71]
transition on GREATER to state [70]
transition on MOD to state [69]
transition on MULTIPLY to state [68]
transition on DIVIDE to state [67]
transition on MINUS to state [66]
transition on AND to state [65]

-------------------
lalr_state [65]: {
  [expr ::= (*) expr BITWISE_OR expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [variable ::= (*) variable LBRACKET expr RBRACKET , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN LBRACKET RBRACKET DOT COMMA PLUSPLUS MINUSMINUS }]
  [expr ::= (*) variable PLUSPLUS , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) expr GREATER expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) expr DIVIDE expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [const_val ::= (*) FLOAT_CONST , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) const_val , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) variable , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) expr EQUAL expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [variable ::= (*) variable DOT IDENTIFIER , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN LBRACKET RBRACKET DOT COMMA PLUSPLUS MINUSMINUS }]
  [expr ::= (*) method_cal , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) expr LESS expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) expr MOD expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [const_val ::= (*) CHAR_CONST , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) SIZEOF LPAREN typeName RPAREN , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) MINUSMINUS variable , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) expr NOT_EQUAL expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) expr PLUS expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [method_cal ::= (*) IDENTIFIER LPAREN parameters RPAREN , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [const_val ::= (*) INT_CONST , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= expr AND (*) expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) MINUS expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) expr AND expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) expr BITWISE_AND expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [const_val ::= (*) BOOL_CONST , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) LPAREN base_type RPAREN expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) PLUSPLUS variable , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) expr GREATER_EQUAL expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) expr MINUS expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [method_cal ::= (*) INPUT LPAREN typeName RPAREN SEMICOLON , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [const_val ::= (*) LONG_CONST , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) BITWISE_NOT expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) expr OR expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) expr BITWISE_XOR expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [const_val ::= (*) STRING_CONST , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [variable ::= (*) IDENTIFIER , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN LBRACKET RBRACKET DOT COMMA PLUSPLUS MINUSMINUS }]
  [expr ::= (*) variable MINUSMINUS , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) expr LESS_EQUAL expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) expr MULTIPLY expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [method_cal ::= (*) INPUT LPAREN RPAREN SEMICOLON , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [const_val ::= (*) DOUBLE_CONST , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) NOT expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) LPAREN expr RPAREN , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
}
transition on CHAR_CONST to state [58]
transition on method_cal to state [57]
transition on const_val to state [56]
transition on LONG_CONST to state [55]
transition on FLOAT_CONST to state [54]
transition on variable to state [53]
transition on MINUS to state [52]
transition on PLUSPLUS to state [51]
transition on BITWISE_NOT to state [50]
transition on INT_CONST to state [49]
transition on LPAREN to state [48]
transition on BOOL_CONST to state [47]
transition on MINUSMINUS to state [46]
transition on IDENTIFIER to state [45]
transition on NOT to state [44]
transition on expr to state [97]
transition on DOUBLE_CONST to state [42]
transition on SIZEOF to state [41]
transition on INPUT to state [6]
transition on STRING_CONST to state [40]

-------------------
lalr_state [66]: {
  [expr ::= (*) expr BITWISE_OR expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [variable ::= (*) variable LBRACKET expr RBRACKET , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN LBRACKET RBRACKET DOT COMMA PLUSPLUS MINUSMINUS }]
  [expr ::= (*) variable PLUSPLUS , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) expr GREATER expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) expr DIVIDE expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [const_val ::= (*) FLOAT_CONST , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) const_val , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) variable , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) expr EQUAL expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [variable ::= (*) variable DOT IDENTIFIER , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN LBRACKET RBRACKET DOT COMMA PLUSPLUS MINUSMINUS }]
  [expr ::= (*) method_cal , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) expr LESS expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) expr MOD expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [const_val ::= (*) CHAR_CONST , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) SIZEOF LPAREN typeName RPAREN , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) MINUSMINUS variable , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) expr NOT_EQUAL expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) expr PLUS expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [method_cal ::= (*) IDENTIFIER LPAREN parameters RPAREN , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [const_val ::= (*) INT_CONST , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) MINUS expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) expr AND expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) expr BITWISE_AND expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [const_val ::= (*) BOOL_CONST , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) LPAREN base_type RPAREN expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) PLUSPLUS variable , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= expr MINUS (*) expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) expr GREATER_EQUAL expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) expr MINUS expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [method_cal ::= (*) INPUT LPAREN typeName RPAREN SEMICOLON , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [const_val ::= (*) LONG_CONST , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) BITWISE_NOT expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) expr OR expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) expr BITWISE_XOR expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [const_val ::= (*) STRING_CONST , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [variable ::= (*) IDENTIFIER , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN LBRACKET RBRACKET DOT COMMA PLUSPLUS MINUSMINUS }]
  [expr ::= (*) variable MINUSMINUS , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) expr LESS_EQUAL expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) expr MULTIPLY expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [method_cal ::= (*) INPUT LPAREN RPAREN SEMICOLON , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [const_val ::= (*) DOUBLE_CONST , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) NOT expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) LPAREN expr RPAREN , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
}
transition on CHAR_CONST to state [58]
transition on method_cal to state [57]
transition on const_val to state [56]
transition on LONG_CONST to state [55]
transition on FLOAT_CONST to state [54]
transition on variable to state [53]
transition on MINUS to state [52]
transition on PLUSPLUS to state [51]
transition on BITWISE_NOT to state [50]
transition on INT_CONST to state [49]
transition on LPAREN to state [48]
transition on BOOL_CONST to state [47]
transition on MINUSMINUS to state [46]
transition on IDENTIFIER to state [45]
transition on NOT to state [44]
transition on expr to state [96]
transition on DOUBLE_CONST to state [42]
transition on SIZEOF to state [41]
transition on INPUT to state [6]
transition on STRING_CONST to state [40]

-------------------
lalr_state [67]: {
  [expr ::= (*) expr BITWISE_OR expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [variable ::= (*) variable LBRACKET expr RBRACKET , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN LBRACKET RBRACKET DOT COMMA PLUSPLUS MINUSMINUS }]
  [expr ::= (*) variable PLUSPLUS , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= expr DIVIDE (*) expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) expr GREATER expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) expr DIVIDE expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [const_val ::= (*) FLOAT_CONST , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) const_val , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) variable , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) expr EQUAL expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [variable ::= (*) variable DOT IDENTIFIER , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN LBRACKET RBRACKET DOT COMMA PLUSPLUS MINUSMINUS }]
  [expr ::= (*) method_cal , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) expr LESS expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) expr MOD expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [const_val ::= (*) CHAR_CONST , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) SIZEOF LPAREN typeName RPAREN , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) MINUSMINUS variable , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) expr NOT_EQUAL expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) expr PLUS expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [method_cal ::= (*) IDENTIFIER LPAREN parameters RPAREN , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [const_val ::= (*) INT_CONST , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) MINUS expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) expr AND expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) expr BITWISE_AND expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [const_val ::= (*) BOOL_CONST , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) LPAREN base_type RPAREN expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) PLUSPLUS variable , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) expr GREATER_EQUAL expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) expr MINUS expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [method_cal ::= (*) INPUT LPAREN typeName RPAREN SEMICOLON , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [const_val ::= (*) LONG_CONST , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) BITWISE_NOT expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) expr OR expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) expr BITWISE_XOR expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [const_val ::= (*) STRING_CONST , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [variable ::= (*) IDENTIFIER , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN LBRACKET RBRACKET DOT COMMA PLUSPLUS MINUSMINUS }]
  [expr ::= (*) variable MINUSMINUS , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) expr LESS_EQUAL expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) expr MULTIPLY expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [method_cal ::= (*) INPUT LPAREN RPAREN SEMICOLON , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [const_val ::= (*) DOUBLE_CONST , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) NOT expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) LPAREN expr RPAREN , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
}
transition on CHAR_CONST to state [58]
transition on method_cal to state [57]
transition on const_val to state [56]
transition on LONG_CONST to state [55]
transition on FLOAT_CONST to state [54]
transition on variable to state [53]
transition on MINUS to state [52]
transition on PLUSPLUS to state [51]
transition on BITWISE_NOT to state [50]
transition on INT_CONST to state [49]
transition on LPAREN to state [48]
transition on BOOL_CONST to state [47]
transition on MINUSMINUS to state [46]
transition on IDENTIFIER to state [45]
transition on NOT to state [44]
transition on expr to state [95]
transition on DOUBLE_CONST to state [42]
transition on SIZEOF to state [41]
transition on INPUT to state [6]
transition on STRING_CONST to state [40]

-------------------
lalr_state [68]: {
  [expr ::= (*) expr BITWISE_OR expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [variable ::= (*) variable LBRACKET expr RBRACKET , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN LBRACKET RBRACKET DOT COMMA PLUSPLUS MINUSMINUS }]
  [expr ::= (*) variable PLUSPLUS , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) expr GREATER expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) expr DIVIDE expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [const_val ::= (*) FLOAT_CONST , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) const_val , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) variable , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) expr EQUAL expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [variable ::= (*) variable DOT IDENTIFIER , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN LBRACKET RBRACKET DOT COMMA PLUSPLUS MINUSMINUS }]
  [expr ::= (*) method_cal , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) expr LESS expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) expr MOD expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [const_val ::= (*) CHAR_CONST , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) SIZEOF LPAREN typeName RPAREN , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) MINUSMINUS variable , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) expr NOT_EQUAL expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) expr PLUS expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [method_cal ::= (*) IDENTIFIER LPAREN parameters RPAREN , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [const_val ::= (*) INT_CONST , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) MINUS expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) expr AND expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) expr BITWISE_AND expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [const_val ::= (*) BOOL_CONST , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) LPAREN base_type RPAREN expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) PLUSPLUS variable , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) expr GREATER_EQUAL expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) expr MINUS expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [method_cal ::= (*) INPUT LPAREN typeName RPAREN SEMICOLON , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [const_val ::= (*) LONG_CONST , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) BITWISE_NOT expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) expr OR expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) expr BITWISE_XOR expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [const_val ::= (*) STRING_CONST , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [variable ::= (*) IDENTIFIER , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN LBRACKET RBRACKET DOT COMMA PLUSPLUS MINUSMINUS }]
  [expr ::= expr MULTIPLY (*) expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) variable MINUSMINUS , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) expr LESS_EQUAL expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) expr MULTIPLY expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [method_cal ::= (*) INPUT LPAREN RPAREN SEMICOLON , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [const_val ::= (*) DOUBLE_CONST , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) NOT expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) LPAREN expr RPAREN , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
}
transition on CHAR_CONST to state [58]
transition on method_cal to state [57]
transition on const_val to state [56]
transition on LONG_CONST to state [55]
transition on FLOAT_CONST to state [54]
transition on variable to state [53]
transition on MINUS to state [52]
transition on PLUSPLUS to state [51]
transition on BITWISE_NOT to state [50]
transition on INT_CONST to state [49]
transition on LPAREN to state [48]
transition on BOOL_CONST to state [47]
transition on MINUSMINUS to state [46]
transition on IDENTIFIER to state [45]
transition on NOT to state [44]
transition on expr to state [94]
transition on DOUBLE_CONST to state [42]
transition on SIZEOF to state [41]
transition on INPUT to state [6]
transition on STRING_CONST to state [40]

-------------------
lalr_state [69]: {
  [expr ::= (*) expr BITWISE_OR expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [variable ::= (*) variable LBRACKET expr RBRACKET , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN LBRACKET RBRACKET DOT COMMA PLUSPLUS MINUSMINUS }]
  [expr ::= (*) variable PLUSPLUS , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) expr GREATER expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) expr DIVIDE expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [const_val ::= (*) FLOAT_CONST , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) const_val , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) variable , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) expr EQUAL expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [variable ::= (*) variable DOT IDENTIFIER , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN LBRACKET RBRACKET DOT COMMA PLUSPLUS MINUSMINUS }]
  [expr ::= (*) method_cal , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= expr MOD (*) expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) expr LESS expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) expr MOD expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [const_val ::= (*) CHAR_CONST , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) SIZEOF LPAREN typeName RPAREN , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) MINUSMINUS variable , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) expr NOT_EQUAL expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) expr PLUS expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [method_cal ::= (*) IDENTIFIER LPAREN parameters RPAREN , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [const_val ::= (*) INT_CONST , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) MINUS expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) expr AND expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) expr BITWISE_AND expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [const_val ::= (*) BOOL_CONST , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) LPAREN base_type RPAREN expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) PLUSPLUS variable , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) expr GREATER_EQUAL expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) expr MINUS expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [method_cal ::= (*) INPUT LPAREN typeName RPAREN SEMICOLON , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [const_val ::= (*) LONG_CONST , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) BITWISE_NOT expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) expr OR expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) expr BITWISE_XOR expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [const_val ::= (*) STRING_CONST , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [variable ::= (*) IDENTIFIER , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN LBRACKET RBRACKET DOT COMMA PLUSPLUS MINUSMINUS }]
  [expr ::= (*) variable MINUSMINUS , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) expr LESS_EQUAL expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) expr MULTIPLY expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [method_cal ::= (*) INPUT LPAREN RPAREN SEMICOLON , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [const_val ::= (*) DOUBLE_CONST , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) NOT expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) LPAREN expr RPAREN , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
}
transition on CHAR_CONST to state [58]
transition on method_cal to state [57]
transition on const_val to state [56]
transition on LONG_CONST to state [55]
transition on FLOAT_CONST to state [54]
transition on variable to state [53]
transition on MINUS to state [52]
transition on PLUSPLUS to state [51]
transition on BITWISE_NOT to state [50]
transition on INT_CONST to state [49]
transition on LPAREN to state [48]
transition on BOOL_CONST to state [47]
transition on MINUSMINUS to state [46]
transition on IDENTIFIER to state [45]
transition on NOT to state [44]
transition on expr to state [93]
transition on DOUBLE_CONST to state [42]
transition on SIZEOF to state [41]
transition on INPUT to state [6]
transition on STRING_CONST to state [40]

-------------------
lalr_state [70]: {
  [expr ::= (*) expr BITWISE_OR expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [variable ::= (*) variable LBRACKET expr RBRACKET , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN LBRACKET RBRACKET DOT COMMA PLUSPLUS MINUSMINUS }]
  [expr ::= expr GREATER (*) expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) variable PLUSPLUS , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) expr GREATER expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) expr DIVIDE expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [const_val ::= (*) FLOAT_CONST , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) const_val , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) variable , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) expr EQUAL expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [variable ::= (*) variable DOT IDENTIFIER , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN LBRACKET RBRACKET DOT COMMA PLUSPLUS MINUSMINUS }]
  [expr ::= (*) method_cal , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) expr LESS expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) expr MOD expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [const_val ::= (*) CHAR_CONST , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) SIZEOF LPAREN typeName RPAREN , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) MINUSMINUS variable , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) expr NOT_EQUAL expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) expr PLUS expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [method_cal ::= (*) IDENTIFIER LPAREN parameters RPAREN , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [const_val ::= (*) INT_CONST , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) MINUS expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) expr AND expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) expr BITWISE_AND expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [const_val ::= (*) BOOL_CONST , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) LPAREN base_type RPAREN expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) PLUSPLUS variable , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) expr GREATER_EQUAL expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) expr MINUS expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [method_cal ::= (*) INPUT LPAREN typeName RPAREN SEMICOLON , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [const_val ::= (*) LONG_CONST , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) BITWISE_NOT expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) expr OR expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) expr BITWISE_XOR expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [const_val ::= (*) STRING_CONST , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [variable ::= (*) IDENTIFIER , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN LBRACKET RBRACKET DOT COMMA PLUSPLUS MINUSMINUS }]
  [expr ::= (*) variable MINUSMINUS , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) expr LESS_EQUAL expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) expr MULTIPLY expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [method_cal ::= (*) INPUT LPAREN RPAREN SEMICOLON , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [const_val ::= (*) DOUBLE_CONST , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) NOT expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) LPAREN expr RPAREN , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
}
transition on CHAR_CONST to state [58]
transition on method_cal to state [57]
transition on const_val to state [56]
transition on LONG_CONST to state [55]
transition on FLOAT_CONST to state [54]
transition on variable to state [53]
transition on MINUS to state [52]
transition on PLUSPLUS to state [51]
transition on BITWISE_NOT to state [50]
transition on INT_CONST to state [49]
transition on LPAREN to state [48]
transition on BOOL_CONST to state [47]
transition on MINUSMINUS to state [46]
transition on IDENTIFIER to state [45]
transition on NOT to state [44]
transition on expr to state [92]
transition on DOUBLE_CONST to state [42]
transition on SIZEOF to state [41]
transition on INPUT to state [6]
transition on STRING_CONST to state [40]

-------------------
lalr_state [71]: {
  [expr ::= (*) expr BITWISE_OR expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [variable ::= (*) variable LBRACKET expr RBRACKET , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN LBRACKET RBRACKET DOT COMMA PLUSPLUS MINUSMINUS }]
  [expr ::= (*) variable PLUSPLUS , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) expr GREATER expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) expr DIVIDE expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [const_val ::= (*) FLOAT_CONST , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) const_val , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= expr EQUAL (*) expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) variable , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) expr EQUAL expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [variable ::= (*) variable DOT IDENTIFIER , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN LBRACKET RBRACKET DOT COMMA PLUSPLUS MINUSMINUS }]
  [expr ::= (*) method_cal , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) expr LESS expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) expr MOD expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [const_val ::= (*) CHAR_CONST , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) SIZEOF LPAREN typeName RPAREN , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) MINUSMINUS variable , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) expr NOT_EQUAL expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) expr PLUS expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [method_cal ::= (*) IDENTIFIER LPAREN parameters RPAREN , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [const_val ::= (*) INT_CONST , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) MINUS expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) expr AND expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) expr BITWISE_AND expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [const_val ::= (*) BOOL_CONST , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) LPAREN base_type RPAREN expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) PLUSPLUS variable , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) expr GREATER_EQUAL expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) expr MINUS expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [method_cal ::= (*) INPUT LPAREN typeName RPAREN SEMICOLON , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [const_val ::= (*) LONG_CONST , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) BITWISE_NOT expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) expr OR expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) expr BITWISE_XOR expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [const_val ::= (*) STRING_CONST , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [variable ::= (*) IDENTIFIER , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN LBRACKET RBRACKET DOT COMMA PLUSPLUS MINUSMINUS }]
  [expr ::= (*) variable MINUSMINUS , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) expr LESS_EQUAL expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) expr MULTIPLY expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [method_cal ::= (*) INPUT LPAREN RPAREN SEMICOLON , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [const_val ::= (*) DOUBLE_CONST , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) NOT expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) LPAREN expr RPAREN , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
}
transition on CHAR_CONST to state [58]
transition on method_cal to state [57]
transition on const_val to state [56]
transition on LONG_CONST to state [55]
transition on FLOAT_CONST to state [54]
transition on variable to state [53]
transition on MINUS to state [52]
transition on PLUSPLUS to state [51]
transition on BITWISE_NOT to state [50]
transition on INT_CONST to state [49]
transition on LPAREN to state [48]
transition on BOOL_CONST to state [47]
transition on MINUSMINUS to state [46]
transition on IDENTIFIER to state [45]
transition on NOT to state [44]
transition on expr to state [91]
transition on DOUBLE_CONST to state [42]
transition on SIZEOF to state [41]
transition on INPUT to state [6]
transition on STRING_CONST to state [40]

-------------------
lalr_state [72]: {
  [expr ::= (*) expr BITWISE_OR expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [variable ::= (*) variable LBRACKET expr RBRACKET , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN LBRACKET RBRACKET DOT COMMA PLUSPLUS MINUSMINUS }]
  [expr ::= (*) variable PLUSPLUS , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) expr GREATER expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) expr DIVIDE expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [const_val ::= (*) FLOAT_CONST , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) const_val , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) variable , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) expr EQUAL expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [variable ::= (*) variable DOT IDENTIFIER , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN LBRACKET RBRACKET DOT COMMA PLUSPLUS MINUSMINUS }]
  [expr ::= (*) method_cal , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) expr LESS expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) expr MOD expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [const_val ::= (*) CHAR_CONST , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) SIZEOF LPAREN typeName RPAREN , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= expr PLUS (*) expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) MINUSMINUS variable , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) expr NOT_EQUAL expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) expr PLUS expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [method_cal ::= (*) IDENTIFIER LPAREN parameters RPAREN , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [const_val ::= (*) INT_CONST , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) MINUS expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) expr AND expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) expr BITWISE_AND expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [const_val ::= (*) BOOL_CONST , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) LPAREN base_type RPAREN expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) PLUSPLUS variable , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) expr GREATER_EQUAL expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) expr MINUS expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [method_cal ::= (*) INPUT LPAREN typeName RPAREN SEMICOLON , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [const_val ::= (*) LONG_CONST , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) BITWISE_NOT expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) expr OR expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) expr BITWISE_XOR expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [const_val ::= (*) STRING_CONST , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [variable ::= (*) IDENTIFIER , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN LBRACKET RBRACKET DOT COMMA PLUSPLUS MINUSMINUS }]
  [expr ::= (*) variable MINUSMINUS , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) expr LESS_EQUAL expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) expr MULTIPLY expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [method_cal ::= (*) INPUT LPAREN RPAREN SEMICOLON , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [const_val ::= (*) DOUBLE_CONST , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) NOT expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) LPAREN expr RPAREN , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
}
transition on CHAR_CONST to state [58]
transition on method_cal to state [57]
transition on const_val to state [56]
transition on LONG_CONST to state [55]
transition on FLOAT_CONST to state [54]
transition on variable to state [53]
transition on MINUS to state [52]
transition on PLUSPLUS to state [51]
transition on BITWISE_NOT to state [50]
transition on INT_CONST to state [49]
transition on LPAREN to state [48]
transition on BOOL_CONST to state [47]
transition on MINUSMINUS to state [46]
transition on IDENTIFIER to state [45]
transition on NOT to state [44]
transition on expr to state [90]
transition on DOUBLE_CONST to state [42]
transition on SIZEOF to state [41]
transition on INPUT to state [6]
transition on STRING_CONST to state [40]

-------------------
lalr_state [73]: {
  [expr ::= (*) expr BITWISE_OR expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [variable ::= (*) variable LBRACKET expr RBRACKET , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN LBRACKET RBRACKET DOT COMMA PLUSPLUS MINUSMINUS }]
  [expr ::= (*) variable PLUSPLUS , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) expr GREATER expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) expr DIVIDE expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [const_val ::= (*) FLOAT_CONST , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) const_val , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) variable , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) expr EQUAL expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [variable ::= (*) variable DOT IDENTIFIER , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN LBRACKET RBRACKET DOT COMMA PLUSPLUS MINUSMINUS }]
  [expr ::= (*) method_cal , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) expr LESS expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) expr MOD expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [const_val ::= (*) CHAR_CONST , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) SIZEOF LPAREN typeName RPAREN , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) MINUSMINUS variable , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) expr NOT_EQUAL expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) expr PLUS expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [method_cal ::= (*) IDENTIFIER LPAREN parameters RPAREN , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [const_val ::= (*) INT_CONST , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) MINUS expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) expr AND expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) expr BITWISE_AND expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [const_val ::= (*) BOOL_CONST , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) LPAREN base_type RPAREN expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) PLUSPLUS variable , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) expr GREATER_EQUAL expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) expr MINUS expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [method_cal ::= (*) INPUT LPAREN typeName RPAREN SEMICOLON , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [const_val ::= (*) LONG_CONST , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) BITWISE_NOT expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) expr OR expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) expr BITWISE_XOR expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [const_val ::= (*) STRING_CONST , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [variable ::= (*) IDENTIFIER , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN LBRACKET RBRACKET DOT COMMA PLUSPLUS MINUSMINUS }]
  [expr ::= (*) variable MINUSMINUS , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) expr LESS_EQUAL expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) expr MULTIPLY expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [method_cal ::= (*) INPUT LPAREN RPAREN SEMICOLON , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [const_val ::= (*) DOUBLE_CONST , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= expr BITWISE_OR (*) expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) NOT expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) LPAREN expr RPAREN , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
}
transition on CHAR_CONST to state [58]
transition on method_cal to state [57]
transition on const_val to state [56]
transition on LONG_CONST to state [55]
transition on FLOAT_CONST to state [54]
transition on variable to state [53]
transition on MINUS to state [52]
transition on PLUSPLUS to state [51]
transition on BITWISE_NOT to state [50]
transition on INT_CONST to state [49]
transition on LPAREN to state [48]
transition on BOOL_CONST to state [47]
transition on MINUSMINUS to state [46]
transition on IDENTIFIER to state [45]
transition on NOT to state [44]
transition on expr to state [89]
transition on DOUBLE_CONST to state [42]
transition on SIZEOF to state [41]
transition on INPUT to state [6]
transition on STRING_CONST to state [40]

-------------------
lalr_state [74]: {
  [variable ::= variable LBRACKET expr RBRACKET (*) , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN LBRACKET RBRACKET DOT COMMA PLUSPLUS MINUSMINUS DIRECT_ASSIGN SUM_ASSIGN DIFF_ASSIGN MULT_ASSIGN DIVIDE_ASSIGN MOD_ASSIGN }]
}

-------------------
lalr_state [75]: {
  [expr ::= (*) expr BITWISE_OR expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [variable ::= (*) variable LBRACKET expr RBRACKET , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN LBRACKET RBRACKET DOT COMMA PLUSPLUS MINUSMINUS }]
  [expr ::= (*) variable PLUSPLUS , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) expr GREATER expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) expr DIVIDE expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [const_val ::= (*) FLOAT_CONST , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) const_val , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) variable , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) expr EQUAL expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [variable ::= (*) variable DOT IDENTIFIER , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN LBRACKET RBRACKET DOT COMMA PLUSPLUS MINUSMINUS }]
  [expr ::= (*) method_cal , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) expr LESS expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) expr MOD expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [const_val ::= (*) CHAR_CONST , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) SIZEOF LPAREN typeName RPAREN , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) MINUSMINUS variable , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) expr NOT_EQUAL expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) expr PLUS expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [method_cal ::= (*) IDENTIFIER LPAREN parameters RPAREN , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [const_val ::= (*) INT_CONST , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) MINUS expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) expr AND expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) expr BITWISE_AND expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [const_val ::= (*) BOOL_CONST , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) LPAREN base_type RPAREN expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) PLUSPLUS variable , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) expr GREATER_EQUAL expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) expr MINUS expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [method_cal ::= (*) INPUT LPAREN typeName RPAREN SEMICOLON , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [const_val ::= (*) LONG_CONST , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) BITWISE_NOT expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) expr OR expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) expr BITWISE_XOR expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [const_val ::= (*) STRING_CONST , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [variable ::= (*) IDENTIFIER , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN LBRACKET RBRACKET DOT COMMA PLUSPLUS MINUSMINUS }]
  [expr ::= expr LESS_EQUAL (*) expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) variable MINUSMINUS , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) expr LESS_EQUAL expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) expr MULTIPLY expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [method_cal ::= (*) INPUT LPAREN RPAREN SEMICOLON , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [const_val ::= (*) DOUBLE_CONST , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) NOT expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) LPAREN expr RPAREN , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
}
transition on CHAR_CONST to state [58]
transition on method_cal to state [57]
transition on const_val to state [56]
transition on LONG_CONST to state [55]
transition on FLOAT_CONST to state [54]
transition on variable to state [53]
transition on MINUS to state [52]
transition on PLUSPLUS to state [51]
transition on BITWISE_NOT to state [50]
transition on INT_CONST to state [49]
transition on LPAREN to state [48]
transition on BOOL_CONST to state [47]
transition on MINUSMINUS to state [46]
transition on IDENTIFIER to state [45]
transition on NOT to state [44]
transition on expr to state [88]
transition on DOUBLE_CONST to state [42]
transition on SIZEOF to state [41]
transition on INPUT to state [6]
transition on STRING_CONST to state [40]

-------------------
lalr_state [76]: {
  [expr ::= (*) expr BITWISE_OR expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [variable ::= (*) variable LBRACKET expr RBRACKET , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN LBRACKET RBRACKET DOT COMMA PLUSPLUS MINUSMINUS }]
  [expr ::= (*) variable PLUSPLUS , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) expr GREATER expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) expr DIVIDE expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [const_val ::= (*) FLOAT_CONST , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) const_val , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) variable , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) expr EQUAL expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [variable ::= (*) variable DOT IDENTIFIER , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN LBRACKET RBRACKET DOT COMMA PLUSPLUS MINUSMINUS }]
  [expr ::= expr LESS (*) expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) method_cal , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) expr LESS expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) expr MOD expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [const_val ::= (*) CHAR_CONST , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) SIZEOF LPAREN typeName RPAREN , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) MINUSMINUS variable , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) expr NOT_EQUAL expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) expr PLUS expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [method_cal ::= (*) IDENTIFIER LPAREN parameters RPAREN , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [const_val ::= (*) INT_CONST , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) MINUS expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) expr AND expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) expr BITWISE_AND expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [const_val ::= (*) BOOL_CONST , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) LPAREN base_type RPAREN expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) PLUSPLUS variable , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) expr GREATER_EQUAL expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) expr MINUS expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [method_cal ::= (*) INPUT LPAREN typeName RPAREN SEMICOLON , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [const_val ::= (*) LONG_CONST , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) BITWISE_NOT expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) expr OR expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) expr BITWISE_XOR expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [const_val ::= (*) STRING_CONST , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [variable ::= (*) IDENTIFIER , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN LBRACKET RBRACKET DOT COMMA PLUSPLUS MINUSMINUS }]
  [expr ::= (*) variable MINUSMINUS , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) expr LESS_EQUAL expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) expr MULTIPLY expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [method_cal ::= (*) INPUT LPAREN RPAREN SEMICOLON , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [const_val ::= (*) DOUBLE_CONST , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) NOT expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) LPAREN expr RPAREN , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
}
transition on CHAR_CONST to state [58]
transition on method_cal to state [57]
transition on const_val to state [56]
transition on LONG_CONST to state [55]
transition on FLOAT_CONST to state [54]
transition on variable to state [53]
transition on MINUS to state [52]
transition on PLUSPLUS to state [51]
transition on BITWISE_NOT to state [50]
transition on INT_CONST to state [49]
transition on LPAREN to state [48]
transition on BOOL_CONST to state [47]
transition on MINUSMINUS to state [46]
transition on IDENTIFIER to state [45]
transition on NOT to state [44]
transition on expr to state [87]
transition on DOUBLE_CONST to state [42]
transition on SIZEOF to state [41]
transition on INPUT to state [6]
transition on STRING_CONST to state [40]

-------------------
lalr_state [77]: {
  [expr ::= (*) expr BITWISE_OR expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [variable ::= (*) variable LBRACKET expr RBRACKET , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN LBRACKET RBRACKET DOT COMMA PLUSPLUS MINUSMINUS }]
  [expr ::= (*) variable PLUSPLUS , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) expr GREATER expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) expr DIVIDE expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [const_val ::= (*) FLOAT_CONST , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) const_val , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) variable , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) expr EQUAL expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [variable ::= (*) variable DOT IDENTIFIER , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN LBRACKET RBRACKET DOT COMMA PLUSPLUS MINUSMINUS }]
  [expr ::= (*) method_cal , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) expr LESS expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) expr MOD expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [const_val ::= (*) CHAR_CONST , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) SIZEOF LPAREN typeName RPAREN , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= expr NOT_EQUAL (*) expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) MINUSMINUS variable , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) expr NOT_EQUAL expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) expr PLUS expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [method_cal ::= (*) IDENTIFIER LPAREN parameters RPAREN , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [const_val ::= (*) INT_CONST , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) MINUS expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) expr AND expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) expr BITWISE_AND expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [const_val ::= (*) BOOL_CONST , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) LPAREN base_type RPAREN expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) PLUSPLUS variable , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) expr GREATER_EQUAL expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) expr MINUS expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [method_cal ::= (*) INPUT LPAREN typeName RPAREN SEMICOLON , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [const_val ::= (*) LONG_CONST , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) BITWISE_NOT expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) expr OR expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) expr BITWISE_XOR expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [const_val ::= (*) STRING_CONST , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [variable ::= (*) IDENTIFIER , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN LBRACKET RBRACKET DOT COMMA PLUSPLUS MINUSMINUS }]
  [expr ::= (*) variable MINUSMINUS , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) expr LESS_EQUAL expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) expr MULTIPLY expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [method_cal ::= (*) INPUT LPAREN RPAREN SEMICOLON , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [const_val ::= (*) DOUBLE_CONST , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) NOT expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) LPAREN expr RPAREN , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
}
transition on CHAR_CONST to state [58]
transition on method_cal to state [57]
transition on const_val to state [56]
transition on LONG_CONST to state [55]
transition on FLOAT_CONST to state [54]
transition on variable to state [53]
transition on MINUS to state [52]
transition on PLUSPLUS to state [51]
transition on BITWISE_NOT to state [50]
transition on INT_CONST to state [49]
transition on LPAREN to state [48]
transition on BOOL_CONST to state [47]
transition on MINUSMINUS to state [46]
transition on IDENTIFIER to state [45]
transition on NOT to state [44]
transition on expr to state [86]
transition on DOUBLE_CONST to state [42]
transition on SIZEOF to state [41]
transition on INPUT to state [6]
transition on STRING_CONST to state [40]

-------------------
lalr_state [78]: {
  [expr ::= (*) expr BITWISE_OR expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [variable ::= (*) variable LBRACKET expr RBRACKET , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN LBRACKET RBRACKET DOT COMMA PLUSPLUS MINUSMINUS }]
  [expr ::= (*) variable PLUSPLUS , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) expr GREATER expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) expr DIVIDE expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [const_val ::= (*) FLOAT_CONST , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) const_val , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) variable , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) expr EQUAL expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [variable ::= (*) variable DOT IDENTIFIER , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN LBRACKET RBRACKET DOT COMMA PLUSPLUS MINUSMINUS }]
  [expr ::= (*) method_cal , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) expr LESS expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) expr MOD expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [const_val ::= (*) CHAR_CONST , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) SIZEOF LPAREN typeName RPAREN , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) MINUSMINUS variable , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) expr NOT_EQUAL expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) expr PLUS expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [method_cal ::= (*) IDENTIFIER LPAREN parameters RPAREN , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [const_val ::= (*) INT_CONST , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) MINUS expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) expr AND expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) expr BITWISE_AND expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [const_val ::= (*) BOOL_CONST , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= expr GREATER_EQUAL (*) expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) LPAREN base_type RPAREN expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) PLUSPLUS variable , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) expr GREATER_EQUAL expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) expr MINUS expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [method_cal ::= (*) INPUT LPAREN typeName RPAREN SEMICOLON , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [const_val ::= (*) LONG_CONST , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) BITWISE_NOT expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) expr OR expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) expr BITWISE_XOR expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [const_val ::= (*) STRING_CONST , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [variable ::= (*) IDENTIFIER , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN LBRACKET RBRACKET DOT COMMA PLUSPLUS MINUSMINUS }]
  [expr ::= (*) variable MINUSMINUS , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) expr LESS_EQUAL expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) expr MULTIPLY expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [method_cal ::= (*) INPUT LPAREN RPAREN SEMICOLON , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [const_val ::= (*) DOUBLE_CONST , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) NOT expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) LPAREN expr RPAREN , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
}
transition on CHAR_CONST to state [58]
transition on method_cal to state [57]
transition on const_val to state [56]
transition on LONG_CONST to state [55]
transition on FLOAT_CONST to state [54]
transition on variable to state [53]
transition on MINUS to state [52]
transition on PLUSPLUS to state [51]
transition on BITWISE_NOT to state [50]
transition on INT_CONST to state [49]
transition on LPAREN to state [48]
transition on BOOL_CONST to state [47]
transition on MINUSMINUS to state [46]
transition on IDENTIFIER to state [45]
transition on NOT to state [44]
transition on expr to state [85]
transition on DOUBLE_CONST to state [42]
transition on SIZEOF to state [41]
transition on INPUT to state [6]
transition on STRING_CONST to state [40]

-------------------
lalr_state [79]: {
  [expr ::= (*) expr BITWISE_OR expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [variable ::= (*) variable LBRACKET expr RBRACKET , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN LBRACKET RBRACKET DOT COMMA PLUSPLUS MINUSMINUS }]
  [expr ::= (*) variable PLUSPLUS , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) expr GREATER expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) expr DIVIDE expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [const_val ::= (*) FLOAT_CONST , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) const_val , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) variable , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) expr EQUAL expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [variable ::= (*) variable DOT IDENTIFIER , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN LBRACKET RBRACKET DOT COMMA PLUSPLUS MINUSMINUS }]
  [expr ::= (*) method_cal , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) expr LESS expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) expr MOD expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [const_val ::= (*) CHAR_CONST , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) SIZEOF LPAREN typeName RPAREN , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) MINUSMINUS variable , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) expr NOT_EQUAL expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) expr PLUS expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [method_cal ::= (*) IDENTIFIER LPAREN parameters RPAREN , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [const_val ::= (*) INT_CONST , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= expr BITWISE_AND (*) expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) MINUS expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) expr AND expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) expr BITWISE_AND expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [const_val ::= (*) BOOL_CONST , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) LPAREN base_type RPAREN expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) PLUSPLUS variable , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) expr GREATER_EQUAL expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) expr MINUS expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [method_cal ::= (*) INPUT LPAREN typeName RPAREN SEMICOLON , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [const_val ::= (*) LONG_CONST , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) BITWISE_NOT expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) expr OR expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) expr BITWISE_XOR expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [const_val ::= (*) STRING_CONST , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [variable ::= (*) IDENTIFIER , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN LBRACKET RBRACKET DOT COMMA PLUSPLUS MINUSMINUS }]
  [expr ::= (*) variable MINUSMINUS , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) expr LESS_EQUAL expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) expr MULTIPLY expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [method_cal ::= (*) INPUT LPAREN RPAREN SEMICOLON , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [const_val ::= (*) DOUBLE_CONST , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) NOT expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) LPAREN expr RPAREN , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
}
transition on CHAR_CONST to state [58]
transition on method_cal to state [57]
transition on const_val to state [56]
transition on LONG_CONST to state [55]
transition on FLOAT_CONST to state [54]
transition on variable to state [53]
transition on MINUS to state [52]
transition on PLUSPLUS to state [51]
transition on BITWISE_NOT to state [50]
transition on INT_CONST to state [49]
transition on LPAREN to state [48]
transition on BOOL_CONST to state [47]
transition on MINUSMINUS to state [46]
transition on IDENTIFIER to state [45]
transition on NOT to state [44]
transition on expr to state [84]
transition on DOUBLE_CONST to state [42]
transition on SIZEOF to state [41]
transition on INPUT to state [6]
transition on STRING_CONST to state [40]

-------------------
lalr_state [80]: {
  [expr ::= (*) expr BITWISE_OR expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [variable ::= (*) variable LBRACKET expr RBRACKET , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN LBRACKET RBRACKET DOT COMMA PLUSPLUS MINUSMINUS }]
  [expr ::= (*) variable PLUSPLUS , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) expr GREATER expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) expr DIVIDE expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [const_val ::= (*) FLOAT_CONST , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) const_val , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) variable , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) expr EQUAL expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [variable ::= (*) variable DOT IDENTIFIER , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN LBRACKET RBRACKET DOT COMMA PLUSPLUS MINUSMINUS }]
  [expr ::= (*) method_cal , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) expr LESS expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) expr MOD expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [const_val ::= (*) CHAR_CONST , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) SIZEOF LPAREN typeName RPAREN , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) MINUSMINUS variable , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) expr NOT_EQUAL expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) expr PLUS expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [method_cal ::= (*) IDENTIFIER LPAREN parameters RPAREN , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [const_val ::= (*) INT_CONST , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) MINUS expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) expr AND expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) expr BITWISE_AND expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [const_val ::= (*) BOOL_CONST , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) LPAREN base_type RPAREN expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) PLUSPLUS variable , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) expr GREATER_EQUAL expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) expr MINUS expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [method_cal ::= (*) INPUT LPAREN typeName RPAREN SEMICOLON , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [const_val ::= (*) LONG_CONST , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) BITWISE_NOT expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= expr BITWISE_XOR (*) expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) expr OR expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) expr BITWISE_XOR expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [const_val ::= (*) STRING_CONST , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [variable ::= (*) IDENTIFIER , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN LBRACKET RBRACKET DOT COMMA PLUSPLUS MINUSMINUS }]
  [expr ::= (*) variable MINUSMINUS , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) expr LESS_EQUAL expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) expr MULTIPLY expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [method_cal ::= (*) INPUT LPAREN RPAREN SEMICOLON , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [const_val ::= (*) DOUBLE_CONST , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) NOT expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) LPAREN expr RPAREN , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
}
transition on CHAR_CONST to state [58]
transition on method_cal to state [57]
transition on const_val to state [56]
transition on LONG_CONST to state [55]
transition on FLOAT_CONST to state [54]
transition on variable to state [53]
transition on MINUS to state [52]
transition on PLUSPLUS to state [51]
transition on BITWISE_NOT to state [50]
transition on INT_CONST to state [49]
transition on LPAREN to state [48]
transition on BOOL_CONST to state [47]
transition on MINUSMINUS to state [46]
transition on IDENTIFIER to state [45]
transition on NOT to state [44]
transition on expr to state [83]
transition on DOUBLE_CONST to state [42]
transition on SIZEOF to state [41]
transition on INPUT to state [6]
transition on STRING_CONST to state [40]

-------------------
lalr_state [81]: {
  [expr ::= (*) expr BITWISE_OR expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [variable ::= (*) variable LBRACKET expr RBRACKET , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN LBRACKET RBRACKET DOT COMMA PLUSPLUS MINUSMINUS }]
  [expr ::= (*) variable PLUSPLUS , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) expr GREATER expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) expr DIVIDE expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [const_val ::= (*) FLOAT_CONST , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) const_val , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) variable , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) expr EQUAL expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [variable ::= (*) variable DOT IDENTIFIER , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN LBRACKET RBRACKET DOT COMMA PLUSPLUS MINUSMINUS }]
  [expr ::= (*) method_cal , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) expr LESS expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) expr MOD expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [const_val ::= (*) CHAR_CONST , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) SIZEOF LPAREN typeName RPAREN , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) MINUSMINUS variable , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) expr NOT_EQUAL expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) expr PLUS expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [method_cal ::= (*) IDENTIFIER LPAREN parameters RPAREN , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [const_val ::= (*) INT_CONST , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) MINUS expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) expr AND expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) expr BITWISE_AND expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [const_val ::= (*) BOOL_CONST , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) LPAREN base_type RPAREN expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) PLUSPLUS variable , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) expr GREATER_EQUAL expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) expr MINUS expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [method_cal ::= (*) INPUT LPAREN typeName RPAREN SEMICOLON , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [const_val ::= (*) LONG_CONST , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= expr OR (*) expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) BITWISE_NOT expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) expr OR expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) expr BITWISE_XOR expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [const_val ::= (*) STRING_CONST , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [variable ::= (*) IDENTIFIER , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN LBRACKET RBRACKET DOT COMMA PLUSPLUS MINUSMINUS }]
  [expr ::= (*) variable MINUSMINUS , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) expr LESS_EQUAL expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) expr MULTIPLY expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [method_cal ::= (*) INPUT LPAREN RPAREN SEMICOLON , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [const_val ::= (*) DOUBLE_CONST , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) NOT expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) LPAREN expr RPAREN , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
}
transition on CHAR_CONST to state [58]
transition on method_cal to state [57]
transition on const_val to state [56]
transition on LONG_CONST to state [55]
transition on FLOAT_CONST to state [54]
transition on variable to state [53]
transition on MINUS to state [52]
transition on PLUSPLUS to state [51]
transition on BITWISE_NOT to state [50]
transition on INT_CONST to state [49]
transition on LPAREN to state [48]
transition on BOOL_CONST to state [47]
transition on MINUSMINUS to state [46]
transition on IDENTIFIER to state [45]
transition on NOT to state [44]
transition on expr to state [82]
transition on DOUBLE_CONST to state [42]
transition on SIZEOF to state [41]
transition on INPUT to state [6]
transition on STRING_CONST to state [40]

-------------------
lalr_state [82]: {
  [expr ::= expr (*) BITWISE_OR expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= expr (*) MOD expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= expr (*) MINUS expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= expr OR expr (*) , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= expr (*) OR expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= expr (*) GREATER expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= expr (*) NOT_EQUAL expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= expr (*) BITWISE_XOR expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= expr (*) DIVIDE expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= expr (*) PLUS expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= expr (*) AND expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= expr (*) LESS_EQUAL expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= expr (*) EQUAL expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= expr (*) BITWISE_AND expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= expr (*) MULTIPLY expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= expr (*) LESS expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= expr (*) GREATER_EQUAL expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
}
transition on OR to state [81]
transition on BITWISE_XOR to state [80]
transition on BITWISE_AND to state [79]
transition on GREATER_EQUAL to state [78]
transition on NOT_EQUAL to state [77]
transition on LESS to state [76]
transition on LESS_EQUAL to state [75]
transition on BITWISE_OR to state [73]
transition on PLUS to state [72]
transition on EQUAL to state [71]
transition on GREATER to state [70]
transition on MOD to state [69]
transition on MULTIPLY to state [68]
transition on DIVIDE to state [67]
transition on MINUS to state [66]
transition on AND to state [65]

-------------------
lalr_state [83]: {
  [expr ::= expr (*) BITWISE_OR expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= expr (*) MOD expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= expr (*) MINUS expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= expr (*) OR expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= expr BITWISE_XOR expr (*) , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= expr (*) GREATER expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= expr (*) NOT_EQUAL expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= expr (*) BITWISE_XOR expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= expr (*) DIVIDE expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= expr (*) PLUS expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= expr (*) AND expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= expr (*) LESS_EQUAL expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= expr (*) EQUAL expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= expr (*) BITWISE_AND expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= expr (*) MULTIPLY expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= expr (*) LESS expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= expr (*) GREATER_EQUAL expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
}
transition on OR to state [81]
transition on BITWISE_XOR to state [80]
transition on BITWISE_AND to state [79]
transition on GREATER_EQUAL to state [78]
transition on NOT_EQUAL to state [77]
transition on LESS to state [76]
transition on LESS_EQUAL to state [75]
transition on BITWISE_OR to state [73]
transition on PLUS to state [72]
transition on EQUAL to state [71]
transition on GREATER to state [70]
transition on MOD to state [69]
transition on MULTIPLY to state [68]
transition on DIVIDE to state [67]
transition on MINUS to state [66]
transition on AND to state [65]

-------------------
lalr_state [84]: {
  [expr ::= expr (*) BITWISE_OR expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= expr (*) MOD expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= expr (*) MINUS expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= expr (*) OR expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= expr (*) GREATER expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= expr (*) NOT_EQUAL expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= expr (*) BITWISE_XOR expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= expr (*) DIVIDE expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= expr (*) PLUS expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= expr (*) AND expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= expr (*) LESS_EQUAL expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= expr BITWISE_AND expr (*) , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= expr (*) EQUAL expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= expr (*) BITWISE_AND expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= expr (*) MULTIPLY expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= expr (*) LESS expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= expr (*) GREATER_EQUAL expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
}
transition on OR to state [81]
transition on BITWISE_XOR to state [80]
transition on BITWISE_AND to state [79]
transition on GREATER_EQUAL to state [78]
transition on NOT_EQUAL to state [77]
transition on LESS to state [76]
transition on LESS_EQUAL to state [75]
transition on BITWISE_OR to state [73]
transition on PLUS to state [72]
transition on EQUAL to state [71]
transition on GREATER to state [70]
transition on MOD to state [69]
transition on MULTIPLY to state [68]
transition on DIVIDE to state [67]
transition on MINUS to state [66]
transition on AND to state [65]

-------------------
lalr_state [85]: {
  [expr ::= expr (*) BITWISE_OR expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= expr (*) MOD expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= expr (*) MINUS expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= expr (*) OR expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= expr (*) GREATER expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= expr (*) NOT_EQUAL expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= expr (*) BITWISE_XOR expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= expr (*) DIVIDE expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= expr (*) PLUS expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= expr (*) AND expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= expr (*) LESS_EQUAL expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= expr (*) EQUAL expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= expr (*) BITWISE_AND expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= expr (*) MULTIPLY expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= expr GREATER_EQUAL expr (*) , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= expr (*) LESS expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= expr (*) GREATER_EQUAL expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
}
transition on OR to state [81]
transition on BITWISE_XOR to state [80]
transition on BITWISE_AND to state [79]
transition on GREATER_EQUAL to state [78]
transition on NOT_EQUAL to state [77]
transition on LESS to state [76]
transition on LESS_EQUAL to state [75]
transition on BITWISE_OR to state [73]
transition on PLUS to state [72]
transition on EQUAL to state [71]
transition on GREATER to state [70]
transition on MOD to state [69]
transition on MULTIPLY to state [68]
transition on DIVIDE to state [67]
transition on MINUS to state [66]
transition on AND to state [65]

-------------------
lalr_state [86]: {
  [expr ::= expr (*) BITWISE_OR expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= expr (*) MOD expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= expr (*) MINUS expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= expr (*) OR expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= expr NOT_EQUAL expr (*) , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= expr (*) GREATER expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= expr (*) NOT_EQUAL expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= expr (*) BITWISE_XOR expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= expr (*) DIVIDE expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= expr (*) PLUS expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= expr (*) AND expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= expr (*) LESS_EQUAL expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= expr (*) EQUAL expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= expr (*) BITWISE_AND expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= expr (*) MULTIPLY expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= expr (*) LESS expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= expr (*) GREATER_EQUAL expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
}
transition on OR to state [81]
transition on BITWISE_XOR to state [80]
transition on BITWISE_AND to state [79]
transition on GREATER_EQUAL to state [78]
transition on NOT_EQUAL to state [77]
transition on LESS to state [76]
transition on LESS_EQUAL to state [75]
transition on BITWISE_OR to state [73]
transition on PLUS to state [72]
transition on EQUAL to state [71]
transition on GREATER to state [70]
transition on MOD to state [69]
transition on MULTIPLY to state [68]
transition on DIVIDE to state [67]
transition on MINUS to state [66]
transition on AND to state [65]

-------------------
lalr_state [87]: {
  [expr ::= expr (*) BITWISE_OR expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= expr (*) MOD expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= expr (*) MINUS expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= expr (*) OR expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= expr (*) GREATER expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= expr (*) NOT_EQUAL expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= expr (*) BITWISE_XOR expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= expr (*) DIVIDE expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= expr (*) PLUS expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= expr (*) AND expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= expr (*) LESS_EQUAL expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= expr (*) EQUAL expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= expr (*) BITWISE_AND expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= expr (*) MULTIPLY expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= expr LESS expr (*) , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= expr (*) LESS expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= expr (*) GREATER_EQUAL expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
}
transition on OR to state [81]
transition on BITWISE_XOR to state [80]
transition on BITWISE_AND to state [79]
transition on GREATER_EQUAL to state [78]
transition on NOT_EQUAL to state [77]
transition on LESS to state [76]
transition on LESS_EQUAL to state [75]
transition on BITWISE_OR to state [73]
transition on PLUS to state [72]
transition on EQUAL to state [71]
transition on GREATER to state [70]
transition on MOD to state [69]
transition on MULTIPLY to state [68]
transition on DIVIDE to state [67]
transition on MINUS to state [66]
transition on AND to state [65]

-------------------
lalr_state [88]: {
  [expr ::= expr (*) BITWISE_OR expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= expr (*) MOD expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= expr (*) MINUS expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= expr (*) OR expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= expr (*) GREATER expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= expr (*) NOT_EQUAL expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= expr (*) BITWISE_XOR expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= expr (*) DIVIDE expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= expr (*) PLUS expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= expr LESS_EQUAL expr (*) , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= expr (*) AND expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= expr (*) LESS_EQUAL expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= expr (*) EQUAL expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= expr (*) BITWISE_AND expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= expr (*) MULTIPLY expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= expr (*) LESS expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= expr (*) GREATER_EQUAL expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
}
transition on OR to state [81]
transition on BITWISE_XOR to state [80]
transition on BITWISE_AND to state [79]
transition on GREATER_EQUAL to state [78]
transition on NOT_EQUAL to state [77]
transition on LESS to state [76]
transition on LESS_EQUAL to state [75]
transition on BITWISE_OR to state [73]
transition on PLUS to state [72]
transition on EQUAL to state [71]
transition on GREATER to state [70]
transition on MOD to state [69]
transition on MULTIPLY to state [68]
transition on DIVIDE to state [67]
transition on MINUS to state [66]
transition on AND to state [65]

-------------------
lalr_state [89]: {
  [expr ::= expr (*) BITWISE_OR expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= expr (*) MOD expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= expr (*) MINUS expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= expr (*) OR expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= expr (*) GREATER expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= expr (*) NOT_EQUAL expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= expr (*) BITWISE_XOR expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= expr (*) DIVIDE expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= expr (*) PLUS expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= expr (*) AND expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= expr (*) LESS_EQUAL expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= expr (*) EQUAL expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= expr (*) BITWISE_AND expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= expr (*) MULTIPLY expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= expr BITWISE_OR expr (*) , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= expr (*) LESS expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= expr (*) GREATER_EQUAL expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
}
transition on OR to state [81]
transition on BITWISE_XOR to state [80]
transition on BITWISE_AND to state [79]
transition on GREATER_EQUAL to state [78]
transition on NOT_EQUAL to state [77]
transition on LESS to state [76]
transition on LESS_EQUAL to state [75]
transition on BITWISE_OR to state [73]
transition on PLUS to state [72]
transition on EQUAL to state [71]
transition on GREATER to state [70]
transition on MOD to state [69]
transition on MULTIPLY to state [68]
transition on DIVIDE to state [67]
transition on MINUS to state [66]
transition on AND to state [65]

-------------------
lalr_state [90]: {
  [expr ::= expr (*) BITWISE_OR expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= expr (*) MOD expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= expr (*) MINUS expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= expr (*) OR expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= expr (*) GREATER expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= expr (*) NOT_EQUAL expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= expr (*) BITWISE_XOR expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= expr PLUS expr (*) , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= expr (*) DIVIDE expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= expr (*) PLUS expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= expr (*) AND expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= expr (*) LESS_EQUAL expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= expr (*) EQUAL expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= expr (*) BITWISE_AND expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= expr (*) MULTIPLY expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= expr (*) LESS expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= expr (*) GREATER_EQUAL expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
}
transition on OR to state [81]
transition on BITWISE_XOR to state [80]
transition on BITWISE_AND to state [79]
transition on GREATER_EQUAL to state [78]
transition on NOT_EQUAL to state [77]
transition on LESS to state [76]
transition on LESS_EQUAL to state [75]
transition on BITWISE_OR to state [73]
transition on PLUS to state [72]
transition on EQUAL to state [71]
transition on GREATER to state [70]
transition on MOD to state [69]
transition on MULTIPLY to state [68]
transition on DIVIDE to state [67]
transition on MINUS to state [66]
transition on AND to state [65]

-------------------
lalr_state [91]: {
  [expr ::= expr (*) BITWISE_OR expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= expr (*) MOD expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= expr (*) MINUS expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= expr (*) OR expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= expr (*) GREATER expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= expr (*) NOT_EQUAL expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= expr (*) BITWISE_XOR expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= expr (*) DIVIDE expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= expr (*) PLUS expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= expr (*) AND expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= expr EQUAL expr (*) , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= expr (*) LESS_EQUAL expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= expr (*) EQUAL expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= expr (*) BITWISE_AND expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= expr (*) MULTIPLY expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= expr (*) LESS expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= expr (*) GREATER_EQUAL expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
}
transition on OR to state [81]
transition on BITWISE_XOR to state [80]
transition on BITWISE_AND to state [79]
transition on GREATER_EQUAL to state [78]
transition on NOT_EQUAL to state [77]
transition on LESS to state [76]
transition on LESS_EQUAL to state [75]
transition on BITWISE_OR to state [73]
transition on PLUS to state [72]
transition on EQUAL to state [71]
transition on GREATER to state [70]
transition on MOD to state [69]
transition on MULTIPLY to state [68]
transition on DIVIDE to state [67]
transition on MINUS to state [66]
transition on AND to state [65]

-------------------
lalr_state [92]: {
  [expr ::= expr (*) BITWISE_OR expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= expr (*) MOD expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= expr (*) MINUS expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= expr GREATER expr (*) , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= expr (*) OR expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= expr (*) GREATER expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= expr (*) NOT_EQUAL expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= expr (*) BITWISE_XOR expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= expr (*) DIVIDE expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= expr (*) PLUS expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= expr (*) AND expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= expr (*) LESS_EQUAL expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= expr (*) EQUAL expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= expr (*) BITWISE_AND expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= expr (*) MULTIPLY expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= expr (*) LESS expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= expr (*) GREATER_EQUAL expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
}
transition on OR to state [81]
transition on BITWISE_XOR to state [80]
transition on BITWISE_AND to state [79]
transition on GREATER_EQUAL to state [78]
transition on NOT_EQUAL to state [77]
transition on LESS to state [76]
transition on LESS_EQUAL to state [75]
transition on BITWISE_OR to state [73]
transition on PLUS to state [72]
transition on EQUAL to state [71]
transition on GREATER to state [70]
transition on MOD to state [69]
transition on MULTIPLY to state [68]
transition on DIVIDE to state [67]
transition on MINUS to state [66]
transition on AND to state [65]

-------------------
lalr_state [93]: {
  [expr ::= expr (*) BITWISE_OR expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= expr (*) MOD expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= expr (*) MINUS expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= expr (*) OR expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= expr (*) GREATER expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= expr (*) NOT_EQUAL expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= expr (*) BITWISE_XOR expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= expr (*) DIVIDE expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= expr (*) PLUS expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= expr (*) AND expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= expr (*) LESS_EQUAL expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= expr (*) EQUAL expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= expr (*) BITWISE_AND expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= expr (*) MULTIPLY expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= expr (*) LESS expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= expr (*) GREATER_EQUAL expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= expr MOD expr (*) , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
}
transition on OR to state [81]
transition on BITWISE_XOR to state [80]
transition on BITWISE_AND to state [79]
transition on GREATER_EQUAL to state [78]
transition on NOT_EQUAL to state [77]
transition on LESS to state [76]
transition on LESS_EQUAL to state [75]
transition on BITWISE_OR to state [73]
transition on PLUS to state [72]
transition on EQUAL to state [71]
transition on GREATER to state [70]
transition on MOD to state [69]
transition on MULTIPLY to state [68]
transition on DIVIDE to state [67]
transition on MINUS to state [66]
transition on AND to state [65]

-------------------
lalr_state [94]: {
  [expr ::= expr (*) BITWISE_OR expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= expr (*) MOD expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= expr (*) MINUS expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= expr (*) OR expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= expr (*) GREATER expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= expr (*) NOT_EQUAL expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= expr (*) BITWISE_XOR expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= expr (*) DIVIDE expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= expr (*) PLUS expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= expr (*) AND expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= expr (*) LESS_EQUAL expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= expr MULTIPLY expr (*) , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= expr (*) EQUAL expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= expr (*) BITWISE_AND expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= expr (*) MULTIPLY expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= expr (*) LESS expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= expr (*) GREATER_EQUAL expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
}
transition on OR to state [81]
transition on BITWISE_XOR to state [80]
transition on BITWISE_AND to state [79]
transition on GREATER_EQUAL to state [78]
transition on NOT_EQUAL to state [77]
transition on LESS to state [76]
transition on LESS_EQUAL to state [75]
transition on BITWISE_OR to state [73]
transition on PLUS to state [72]
transition on EQUAL to state [71]
transition on GREATER to state [70]
transition on MOD to state [69]
transition on MULTIPLY to state [68]
transition on DIVIDE to state [67]
transition on MINUS to state [66]
transition on AND to state [65]

-------------------
lalr_state [95]: {
  [expr ::= expr (*) BITWISE_OR expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= expr (*) MOD expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= expr (*) MINUS expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= expr (*) OR expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= expr (*) GREATER expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= expr DIVIDE expr (*) , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= expr (*) NOT_EQUAL expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= expr (*) BITWISE_XOR expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= expr (*) DIVIDE expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= expr (*) PLUS expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= expr (*) AND expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= expr (*) LESS_EQUAL expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= expr (*) EQUAL expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= expr (*) BITWISE_AND expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= expr (*) MULTIPLY expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= expr (*) LESS expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= expr (*) GREATER_EQUAL expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
}
transition on OR to state [81]
transition on BITWISE_XOR to state [80]
transition on BITWISE_AND to state [79]
transition on GREATER_EQUAL to state [78]
transition on NOT_EQUAL to state [77]
transition on LESS to state [76]
transition on LESS_EQUAL to state [75]
transition on BITWISE_OR to state [73]
transition on PLUS to state [72]
transition on EQUAL to state [71]
transition on GREATER to state [70]
transition on MOD to state [69]
transition on MULTIPLY to state [68]
transition on DIVIDE to state [67]
transition on MINUS to state [66]
transition on AND to state [65]

-------------------
lalr_state [96]: {
  [expr ::= expr MINUS expr (*) , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= expr (*) BITWISE_OR expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= expr (*) MOD expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= expr (*) MINUS expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= expr (*) OR expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= expr (*) GREATER expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= expr (*) NOT_EQUAL expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= expr (*) BITWISE_XOR expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= expr (*) DIVIDE expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= expr (*) PLUS expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= expr (*) AND expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= expr (*) LESS_EQUAL expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= expr (*) EQUAL expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= expr (*) BITWISE_AND expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= expr (*) MULTIPLY expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= expr (*) LESS expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= expr (*) GREATER_EQUAL expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
}
transition on OR to state [81]
transition on BITWISE_XOR to state [80]
transition on BITWISE_AND to state [79]
transition on GREATER_EQUAL to state [78]
transition on NOT_EQUAL to state [77]
transition on LESS to state [76]
transition on LESS_EQUAL to state [75]
transition on BITWISE_OR to state [73]
transition on PLUS to state [72]
transition on EQUAL to state [71]
transition on GREATER to state [70]
transition on MOD to state [69]
transition on MULTIPLY to state [68]
transition on DIVIDE to state [67]
transition on MINUS to state [66]
transition on AND to state [65]

-------------------
lalr_state [97]: {
  [expr ::= expr (*) BITWISE_OR expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= expr (*) MOD expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= expr (*) MINUS expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= expr (*) OR expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= expr (*) GREATER expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= expr (*) NOT_EQUAL expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= expr (*) BITWISE_XOR expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= expr (*) DIVIDE expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= expr (*) PLUS expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= expr AND expr (*) , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= expr (*) AND expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= expr (*) LESS_EQUAL expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= expr (*) EQUAL expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= expr (*) BITWISE_AND expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= expr (*) MULTIPLY expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= expr (*) LESS expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= expr (*) GREATER_EQUAL expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
}
transition on OR to state [81]
transition on BITWISE_XOR to state [80]
transition on BITWISE_AND to state [79]
transition on GREATER_EQUAL to state [78]
transition on NOT_EQUAL to state [77]
transition on LESS to state [76]
transition on LESS_EQUAL to state [75]
transition on BITWISE_OR to state [73]
transition on PLUS to state [72]
transition on EQUAL to state [71]
transition on GREATER to state [70]
transition on MOD to state [69]
transition on MULTIPLY to state [68]
transition on DIVIDE to state [67]
transition on MINUS to state [66]
transition on AND to state [65]

-------------------
lalr_state [98]: {
  [expr ::= expr (*) BITWISE_OR expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= expr (*) MOD expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= expr (*) MINUS expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= expr (*) OR expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= expr (*) GREATER expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= expr (*) NOT_EQUAL expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= expr (*) BITWISE_XOR expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= MINUS expr (*) , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= expr (*) DIVIDE expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= expr (*) PLUS expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= expr (*) AND expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= expr (*) LESS_EQUAL expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= expr (*) EQUAL expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= expr (*) BITWISE_AND expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= expr (*) MULTIPLY expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= expr (*) LESS expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= expr (*) GREATER_EQUAL expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
}
transition on OR to state [81]
transition on BITWISE_XOR to state [80]
transition on BITWISE_AND to state [79]
transition on GREATER_EQUAL to state [78]
transition on NOT_EQUAL to state [77]
transition on LESS to state [76]
transition on LESS_EQUAL to state [75]
transition on BITWISE_OR to state [73]
transition on PLUS to state [72]
transition on EQUAL to state [71]
transition on GREATER to state [70]
transition on MOD to state [69]
transition on MULTIPLY to state [68]
transition on DIVIDE to state [67]
transition on MINUS to state [66]
transition on AND to state [65]

-------------------
lalr_state [99]: {
  [expr ::= PLUSPLUS variable (*) , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [variable ::= variable (*) DOT IDENTIFIER , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN LBRACKET RBRACKET DOT COMMA }]
  [variable ::= variable (*) LBRACKET expr RBRACKET , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN LBRACKET RBRACKET DOT COMMA }]
}
transition on DOT to state [62]
transition on LBRACKET to state [60]

-------------------
lalr_state [100]: {
  [variable ::= IDENTIFIER (*) , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN LBRACKET RBRACKET DOT COMMA DIRECT_ASSIGN SUM_ASSIGN DIFF_ASSIGN MULT_ASSIGN DIVIDE_ASSIGN MOD_ASSIGN }]
}

-------------------
lalr_state [101]: {
  [expr ::= expr (*) BITWISE_OR expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= BITWISE_NOT expr (*) , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= expr (*) MOD expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= expr (*) MINUS expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= expr (*) OR expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= expr (*) GREATER expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= expr (*) NOT_EQUAL expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= expr (*) BITWISE_XOR expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= expr (*) DIVIDE expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= expr (*) PLUS expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= expr (*) AND expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= expr (*) LESS_EQUAL expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= expr (*) EQUAL expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= expr (*) BITWISE_AND expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= expr (*) MULTIPLY expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= expr (*) LESS expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= expr (*) GREATER_EQUAL expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
}
transition on OR to state [81]
transition on BITWISE_XOR to state [80]
transition on BITWISE_AND to state [79]
transition on GREATER_EQUAL to state [78]
transition on NOT_EQUAL to state [77]
transition on LESS to state [76]
transition on LESS_EQUAL to state [75]
transition on BITWISE_OR to state [73]
transition on PLUS to state [72]
transition on EQUAL to state [71]
transition on GREATER to state [70]
transition on MOD to state [69]
transition on MULTIPLY to state [68]
transition on DIVIDE to state [67]
transition on MINUS to state [66]
transition on AND to state [65]

-------------------
lalr_state [102]: {
  [expr ::= expr (*) BITWISE_OR expr , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [expr ::= expr (*) MOD expr , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [expr ::= expr (*) MINUS expr , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [expr ::= expr (*) OR expr , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [expr ::= expr (*) GREATER expr , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [expr ::= expr (*) NOT_EQUAL expr , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [expr ::= expr (*) BITWISE_XOR expr , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [expr ::= expr (*) DIVIDE expr , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [expr ::= expr (*) PLUS expr , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [expr ::= expr (*) AND expr , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [expr ::= expr (*) LESS_EQUAL expr , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [expr ::= expr (*) EQUAL expr , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [expr ::= expr (*) BITWISE_AND expr , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [expr ::= expr (*) MULTIPLY expr , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [expr ::= LPAREN expr (*) RPAREN , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= expr (*) LESS expr , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [expr ::= expr (*) GREATER_EQUAL expr , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
}
transition on OR to state [81]
transition on BITWISE_XOR to state [80]
transition on BITWISE_AND to state [79]
transition on GREATER_EQUAL to state [78]
transition on RPAREN to state [106]
transition on NOT_EQUAL to state [77]
transition on LESS to state [76]
transition on LESS_EQUAL to state [75]
transition on BITWISE_OR to state [73]
transition on PLUS to state [72]
transition on EQUAL to state [71]
transition on GREATER to state [70]
transition on MOD to state [69]
transition on MULTIPLY to state [68]
transition on DIVIDE to state [67]
transition on MINUS to state [66]
transition on AND to state [65]

-------------------
lalr_state [103]: {
  [expr ::= LPAREN base_type (*) RPAREN expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
}
transition on RPAREN to state [104]

-------------------
lalr_state [104]: {
  [expr ::= (*) expr BITWISE_OR expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [variable ::= (*) variable LBRACKET expr RBRACKET , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN LBRACKET RBRACKET DOT COMMA PLUSPLUS MINUSMINUS }]
  [expr ::= (*) variable PLUSPLUS , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) expr GREATER expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) expr DIVIDE expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [const_val ::= (*) FLOAT_CONST , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) const_val , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) variable , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) expr EQUAL expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [variable ::= (*) variable DOT IDENTIFIER , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN LBRACKET RBRACKET DOT COMMA PLUSPLUS MINUSMINUS }]
  [expr ::= (*) method_cal , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) expr LESS expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) expr MOD expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [const_val ::= (*) CHAR_CONST , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) SIZEOF LPAREN typeName RPAREN , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) MINUSMINUS variable , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) expr NOT_EQUAL expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) expr PLUS expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [method_cal ::= (*) IDENTIFIER LPAREN parameters RPAREN , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [const_val ::= (*) INT_CONST , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) MINUS expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) expr AND expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) expr BITWISE_AND expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= LPAREN base_type RPAREN (*) expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [const_val ::= (*) BOOL_CONST , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) LPAREN base_type RPAREN expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) PLUSPLUS variable , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) expr GREATER_EQUAL expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) expr MINUS expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [method_cal ::= (*) INPUT LPAREN typeName RPAREN SEMICOLON , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [const_val ::= (*) LONG_CONST , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) BITWISE_NOT expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) expr OR expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) expr BITWISE_XOR expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [const_val ::= (*) STRING_CONST , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [variable ::= (*) IDENTIFIER , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN LBRACKET RBRACKET DOT COMMA PLUSPLUS MINUSMINUS }]
  [expr ::= (*) variable MINUSMINUS , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) expr LESS_EQUAL expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) expr MULTIPLY expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [method_cal ::= (*) INPUT LPAREN RPAREN SEMICOLON , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [const_val ::= (*) DOUBLE_CONST , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) NOT expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= (*) LPAREN expr RPAREN , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
}
transition on CHAR_CONST to state [58]
transition on method_cal to state [57]
transition on const_val to state [56]
transition on LONG_CONST to state [55]
transition on FLOAT_CONST to state [54]
transition on variable to state [53]
transition on MINUS to state [52]
transition on PLUSPLUS to state [51]
transition on BITWISE_NOT to state [50]
transition on INT_CONST to state [49]
transition on LPAREN to state [48]
transition on BOOL_CONST to state [47]
transition on MINUSMINUS to state [46]
transition on IDENTIFIER to state [45]
transition on NOT to state [44]
transition on expr to state [105]
transition on DOUBLE_CONST to state [42]
transition on SIZEOF to state [41]
transition on INPUT to state [6]
transition on STRING_CONST to state [40]

-------------------
lalr_state [105]: {
  [expr ::= expr (*) BITWISE_OR expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= expr (*) MOD expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= expr (*) MINUS expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= expr (*) OR expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= expr (*) GREATER expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= expr (*) NOT_EQUAL expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= expr (*) BITWISE_XOR expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= expr (*) DIVIDE expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= expr (*) PLUS expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= LPAREN base_type RPAREN expr (*) , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= expr (*) AND expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= expr (*) LESS_EQUAL expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= expr (*) EQUAL expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= expr (*) BITWISE_AND expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= expr (*) MULTIPLY expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= expr (*) LESS expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= expr (*) GREATER_EQUAL expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
}
transition on OR to state [81]
transition on BITWISE_XOR to state [80]
transition on BITWISE_AND to state [79]
transition on GREATER_EQUAL to state [78]
transition on NOT_EQUAL to state [77]
transition on LESS to state [76]
transition on LESS_EQUAL to state [75]
transition on BITWISE_OR to state [73]
transition on PLUS to state [72]
transition on EQUAL to state [71]
transition on GREATER to state [70]
transition on MOD to state [69]
transition on MULTIPLY to state [68]
transition on DIVIDE to state [67]
transition on MINUS to state [66]
transition on AND to state [65]

-------------------
lalr_state [106]: {
  [expr ::= LPAREN expr RPAREN (*) , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
}

-------------------
lalr_state [107]: {
  [expr ::= MINUSMINUS variable (*) , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [variable ::= variable (*) DOT IDENTIFIER , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN LBRACKET RBRACKET DOT COMMA }]
  [variable ::= variable (*) LBRACKET expr RBRACKET , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN LBRACKET RBRACKET DOT COMMA }]
}
transition on DOT to state [62]
transition on LBRACKET to state [60]

-------------------
lalr_state [108]: {
  [expr ::= (*) expr BITWISE_OR expr , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN COMMA }]
  [variable ::= (*) variable LBRACKET expr RBRACKET , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN LBRACKET DOT COMMA PLUSPLUS MINUSMINUS }]
  [expr ::= (*) variable PLUSPLUS , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN COMMA }]
  [expr ::= (*) expr GREATER expr , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN COMMA }]
  [expr ::= (*) expr DIVIDE expr , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN COMMA }]
  [parameters ::= (*) expr , {RPAREN }]
  [const_val ::= (*) FLOAT_CONST , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN COMMA }]
  [expr ::= (*) const_val , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN COMMA }]
  [expr ::= (*) variable , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN COMMA }]
  [expr ::= (*) expr EQUAL expr , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN COMMA }]
  [variable ::= (*) variable DOT IDENTIFIER , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN LBRACKET DOT COMMA PLUSPLUS MINUSMINUS }]
  [expr ::= (*) method_cal , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN COMMA }]
  [expr ::= (*) expr LESS expr , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN COMMA }]
  [expr ::= (*) expr MOD expr , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN COMMA }]
  [parameters ::= (*) expr COMMA parameters , {RPAREN }]
  [const_val ::= (*) CHAR_CONST , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN COMMA }]
  [expr ::= (*) SIZEOF LPAREN typeName RPAREN , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN COMMA }]
  [expr ::= (*) MINUSMINUS variable , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN COMMA }]
  [expr ::= (*) expr NOT_EQUAL expr , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN COMMA }]
  [expr ::= (*) expr PLUS expr , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN COMMA }]
  [method_cal ::= IDENTIFIER LPAREN (*) parameters RPAREN , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [method_cal ::= (*) IDENTIFIER LPAREN parameters RPAREN , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN COMMA }]
  [const_val ::= (*) INT_CONST , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN COMMA }]
  [expr ::= (*) MINUS expr , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN COMMA }]
  [expr ::= (*) expr AND expr , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN COMMA }]
  [expr ::= (*) expr BITWISE_AND expr , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN COMMA }]
  [const_val ::= (*) BOOL_CONST , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN COMMA }]
  [expr ::= (*) LPAREN base_type RPAREN expr , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN COMMA }]
  [expr ::= (*) PLUSPLUS variable , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN COMMA }]
  [expr ::= (*) expr GREATER_EQUAL expr , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN COMMA }]
  [expr ::= (*) expr MINUS expr , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN COMMA }]
  [method_cal ::= (*) INPUT LPAREN typeName RPAREN SEMICOLON , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN COMMA }]
  [const_val ::= (*) LONG_CONST , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN COMMA }]
  [expr ::= (*) BITWISE_NOT expr , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN COMMA }]
  [expr ::= (*) expr OR expr , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN COMMA }]
  [expr ::= (*) expr BITWISE_XOR expr , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN COMMA }]
  [const_val ::= (*) STRING_CONST , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN COMMA }]
  [variable ::= (*) IDENTIFIER , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN LBRACKET DOT COMMA PLUSPLUS MINUSMINUS }]
  [expr ::= (*) variable MINUSMINUS , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN COMMA }]
  [expr ::= (*) expr LESS_EQUAL expr , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN COMMA }]
  [expr ::= (*) expr MULTIPLY expr , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN COMMA }]
  [method_cal ::= (*) INPUT LPAREN RPAREN SEMICOLON , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN COMMA }]
  [const_val ::= (*) DOUBLE_CONST , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN COMMA }]
  [expr ::= (*) NOT expr , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN COMMA }]
  [expr ::= (*) LPAREN expr RPAREN , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN COMMA }]
}
transition on CHAR_CONST to state [58]
transition on method_cal to state [57]
transition on const_val to state [56]
transition on LONG_CONST to state [55]
transition on FLOAT_CONST to state [54]
transition on variable to state [53]
transition on MINUS to state [52]
transition on PLUSPLUS to state [51]
transition on BITWISE_NOT to state [50]
transition on INT_CONST to state [49]
transition on LPAREN to state [48]
transition on BOOL_CONST to state [47]
transition on parameters to state [110]
transition on MINUSMINUS to state [46]
transition on IDENTIFIER to state [45]
transition on NOT to state [44]
transition on expr to state [109]
transition on DOUBLE_CONST to state [42]
transition on SIZEOF to state [41]
transition on INPUT to state [6]
transition on STRING_CONST to state [40]

-------------------
lalr_state [109]: {
  [expr ::= expr (*) DIVIDE expr , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN COMMA }]
  [expr ::= expr (*) EQUAL expr , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN COMMA }]
  [expr ::= expr (*) LESS expr , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN COMMA }]
  [parameters ::= expr (*) COMMA parameters , {RPAREN }]
  [expr ::= expr (*) MINUS expr , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN COMMA }]
  [expr ::= expr (*) BITWISE_XOR expr , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN COMMA }]
  [expr ::= expr (*) LESS_EQUAL expr , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN COMMA }]
  [expr ::= expr (*) MOD expr , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN COMMA }]
  [expr ::= expr (*) NOT_EQUAL expr , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN COMMA }]
  [expr ::= expr (*) AND expr , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN COMMA }]
  [expr ::= expr (*) MULTIPLY expr , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN COMMA }]
  [expr ::= expr (*) BITWISE_OR expr , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN COMMA }]
  [expr ::= expr (*) GREATER expr , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN COMMA }]
  [parameters ::= expr (*) , {RPAREN }]
  [expr ::= expr (*) PLUS expr , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN COMMA }]
  [expr ::= expr (*) BITWISE_AND expr , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN COMMA }]
  [expr ::= expr (*) GREATER_EQUAL expr , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN COMMA }]
  [expr ::= expr (*) OR expr , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN COMMA }]
}
transition on OR to state [81]
transition on BITWISE_XOR to state [80]
transition on BITWISE_AND to state [79]
transition on GREATER_EQUAL to state [78]
transition on COMMA to state [112]
transition on LESS to state [76]
transition on NOT_EQUAL to state [77]
transition on LESS_EQUAL to state [75]
transition on BITWISE_OR to state [73]
transition on PLUS to state [72]
transition on EQUAL to state [71]
transition on GREATER to state [70]
transition on MOD to state [69]
transition on MULTIPLY to state [68]
transition on DIVIDE to state [67]
transition on MINUS to state [66]
transition on AND to state [65]

-------------------
lalr_state [110]: {
  [method_cal ::= IDENTIFIER LPAREN parameters (*) RPAREN , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
}
transition on RPAREN to state [111]

-------------------
lalr_state [111]: {
  [method_cal ::= IDENTIFIER LPAREN parameters RPAREN (*) , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
}

-------------------
lalr_state [112]: {
  [expr ::= (*) expr BITWISE_OR expr , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN COMMA }]
  [variable ::= (*) variable LBRACKET expr RBRACKET , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN LBRACKET DOT COMMA PLUSPLUS MINUSMINUS }]
  [expr ::= (*) variable PLUSPLUS , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN COMMA }]
  [expr ::= (*) expr GREATER expr , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN COMMA }]
  [expr ::= (*) expr DIVIDE expr , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN COMMA }]
  [parameters ::= (*) expr , {RPAREN }]
  [const_val ::= (*) FLOAT_CONST , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN COMMA }]
  [expr ::= (*) const_val , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN COMMA }]
  [expr ::= (*) variable , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN COMMA }]
  [expr ::= (*) expr EQUAL expr , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN COMMA }]
  [variable ::= (*) variable DOT IDENTIFIER , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN LBRACKET DOT COMMA PLUSPLUS MINUSMINUS }]
  [expr ::= (*) method_cal , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN COMMA }]
  [expr ::= (*) expr LESS expr , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN COMMA }]
  [expr ::= (*) expr MOD expr , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN COMMA }]
  [parameters ::= expr COMMA (*) parameters , {RPAREN }]
  [parameters ::= (*) expr COMMA parameters , {RPAREN }]
  [const_val ::= (*) CHAR_CONST , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN COMMA }]
  [expr ::= (*) SIZEOF LPAREN typeName RPAREN , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN COMMA }]
  [expr ::= (*) MINUSMINUS variable , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN COMMA }]
  [expr ::= (*) expr NOT_EQUAL expr , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN COMMA }]
  [expr ::= (*) expr PLUS expr , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN COMMA }]
  [method_cal ::= (*) IDENTIFIER LPAREN parameters RPAREN , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN COMMA }]
  [const_val ::= (*) INT_CONST , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN COMMA }]
  [expr ::= (*) MINUS expr , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN COMMA }]
  [expr ::= (*) expr AND expr , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN COMMA }]
  [expr ::= (*) expr BITWISE_AND expr , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN COMMA }]
  [const_val ::= (*) BOOL_CONST , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN COMMA }]
  [expr ::= (*) LPAREN base_type RPAREN expr , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN COMMA }]
  [expr ::= (*) PLUSPLUS variable , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN COMMA }]
  [expr ::= (*) expr GREATER_EQUAL expr , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN COMMA }]
  [expr ::= (*) expr MINUS expr , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN COMMA }]
  [method_cal ::= (*) INPUT LPAREN typeName RPAREN SEMICOLON , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN COMMA }]
  [const_val ::= (*) LONG_CONST , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN COMMA }]
  [expr ::= (*) BITWISE_NOT expr , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN COMMA }]
  [expr ::= (*) expr OR expr , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN COMMA }]
  [expr ::= (*) expr BITWISE_XOR expr , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN COMMA }]
  [const_val ::= (*) STRING_CONST , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN COMMA }]
  [variable ::= (*) IDENTIFIER , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN LBRACKET DOT COMMA PLUSPLUS MINUSMINUS }]
  [expr ::= (*) variable MINUSMINUS , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN COMMA }]
  [expr ::= (*) expr LESS_EQUAL expr , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN COMMA }]
  [expr ::= (*) expr MULTIPLY expr , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN COMMA }]
  [method_cal ::= (*) INPUT LPAREN RPAREN SEMICOLON , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN COMMA }]
  [const_val ::= (*) DOUBLE_CONST , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN COMMA }]
  [expr ::= (*) NOT expr , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN COMMA }]
  [expr ::= (*) LPAREN expr RPAREN , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN COMMA }]
}
transition on CHAR_CONST to state [58]
transition on method_cal to state [57]
transition on const_val to state [56]
transition on LONG_CONST to state [55]
transition on FLOAT_CONST to state [54]
transition on variable to state [53]
transition on MINUS to state [52]
transition on PLUSPLUS to state [51]
transition on BITWISE_NOT to state [50]
transition on INT_CONST to state [49]
transition on LPAREN to state [48]
transition on BOOL_CONST to state [47]
transition on MINUSMINUS to state [46]
transition on parameters to state [113]
transition on IDENTIFIER to state [45]
transition on NOT to state [44]
transition on expr to state [109]
transition on DOUBLE_CONST to state [42]
transition on SIZEOF to state [41]
transition on INPUT to state [6]
transition on STRING_CONST to state [40]

-------------------
lalr_state [113]: {
  [parameters ::= expr COMMA parameters (*) , {RPAREN }]
}

-------------------
lalr_state [114]: {
  [expr ::= expr (*) BITWISE_OR expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= expr (*) MOD expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= expr (*) MINUS expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= expr (*) OR expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= expr (*) GREATER expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= expr (*) NOT_EQUAL expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= expr (*) BITWISE_XOR expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= expr (*) DIVIDE expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= expr (*) PLUS expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= expr (*) AND expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= expr (*) LESS_EQUAL expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= expr (*) EQUAL expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= NOT expr (*) , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= expr (*) BITWISE_AND expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= expr (*) MULTIPLY expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= expr (*) LESS expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [expr ::= expr (*) GREATER_EQUAL expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
}
transition on OR to state [81]
transition on BITWISE_XOR to state [80]
transition on BITWISE_AND to state [79]
transition on GREATER_EQUAL to state [78]
transition on NOT_EQUAL to state [77]
transition on LESS to state [76]
transition on LESS_EQUAL to state [75]
transition on BITWISE_OR to state [73]
transition on PLUS to state [72]
transition on EQUAL to state [71]
transition on GREATER to state [70]
transition on MOD to state [69]
transition on MULTIPLY to state [68]
transition on DIVIDE to state [67]
transition on MINUS to state [66]
transition on AND to state [65]

-------------------
lalr_state [115]: {
  [loop_stmt ::= REPEAT block UNTIL LPAREN expr RPAREN (*) SEMICOLON , {IDENTIFIER INT LONG FLOAT DOUBLE BOOL CHAR STRING AUTO IF RETURN BREAK CONTINUE SWITCH END FOR REPEAT FOREACH CONST PRINTLN INPUT }]
}
transition on SEMICOLON to state [116]

-------------------
lalr_state [116]: {
  [loop_stmt ::= REPEAT block UNTIL LPAREN expr RPAREN SEMICOLON (*) , {IDENTIFIER INT LONG FLOAT DOUBLE BOOL CHAR STRING AUTO IF RETURN BREAK CONTINUE SWITCH END FOR REPEAT FOREACH CONST PRINTLN INPUT }]
}

-------------------
lalr_state [117]: {
  [expr ::= SIZEOF LPAREN (*) typeName RPAREN , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [base_type ::= (*) BOOL , {RPAREN }]
  [base_type ::= (*) LONG , {RPAREN }]
  [base_type ::= (*) STRING , {RPAREN }]
  [base_type ::= (*) DOUBLE , {RPAREN }]
  [base_type ::= (*) INT , {RPAREN }]
  [typeName ::= (*) IDENTIFIER , {RPAREN }]
  [base_type ::= (*) CHAR , {RPAREN }]
  [base_type ::= (*) FLOAT , {RPAREN }]
  [typeName ::= (*) base_type , {RPAREN }]
}
transition on CHAR to state [11]
transition on FLOAT to state [21]
transition on base_type to state [30]
transition on typeName to state [119]
transition on IDENTIFIER to state [118]
transition on DOUBLE to state [36]
transition on STRING to state [19]
transition on BOOL to state [31]
transition on LONG to state [7]
transition on INT to state [10]

-------------------
lalr_state [118]: {
  [typeName ::= IDENTIFIER (*) , {RPAREN LRBRACKET IDENTIFIER }]
}

-------------------
lalr_state [119]: {
  [expr ::= SIZEOF LPAREN typeName (*) RPAREN , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
}
transition on RPAREN to state [120]

-------------------
lalr_state [120]: {
  [expr ::= SIZEOF LPAREN typeName RPAREN (*) , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
}

-------------------
lalr_state [121]: {
  [assignment ::= (*) variable MOD_ASSIGN expr , {SEMICOLON }]
  [assignment ::= (*) variable DIFF_ASSIGN expr , {SEMICOLON }]
  [loop_stmt ::= FOR LPAREN (*) for_init_part SEMICOLON expr SEMICOLON RPAREN block , {IDENTIFIER INT LONG FLOAT DOUBLE BOOL CHAR STRING AUTO IF RETURN BREAK CONTINUE SWITCH END FOR REPEAT FOREACH CONST PRINTLN INPUT }]
  [for_init_part ::= (*) , {SEMICOLON }]
  [variable ::= (*) IDENTIFIER , {LBRACKET DOT DIRECT_ASSIGN SUM_ASSIGN DIFF_ASSIGN MULT_ASSIGN DIVIDE_ASSIGN MOD_ASSIGN }]
  [assignment ::= (*) variable DIVIDE_ASSIGN expr , {SEMICOLON }]
  [assignment ::= (*) variable SUM_ASSIGN expr , {SEMICOLON }]
  [loop_stmt ::= FOR LPAREN (*) for_init_part SEMICOLON expr SEMICOLON expr RPAREN block , {IDENTIFIER INT LONG FLOAT DOUBLE BOOL CHAR STRING AUTO IF RETURN BREAK CONTINUE SWITCH END FOR REPEAT FOREACH CONST PRINTLN INPUT }]
  [variable ::= (*) variable DOT IDENTIFIER , {LBRACKET DOT DIRECT_ASSIGN SUM_ASSIGN DIFF_ASSIGN MULT_ASSIGN DIVIDE_ASSIGN MOD_ASSIGN }]
  [assignment ::= (*) variable MULT_ASSIGN expr , {SEMICOLON }]
  [assignment ::= (*) variable DIRECT_ASSIGN expr , {SEMICOLON }]
  [loop_stmt ::= FOR LPAREN (*) for_init_part SEMICOLON expr SEMICOLON assignment RPAREN block , {IDENTIFIER INT LONG FLOAT DOUBLE BOOL CHAR STRING AUTO IF RETURN BREAK CONTINUE SWITCH END FOR REPEAT FOREACH CONST PRINTLN INPUT }]
  [for_init_part ::= (*) assignment , {SEMICOLON }]
  [variable ::= (*) variable LBRACKET expr RBRACKET , {LBRACKET DOT DIRECT_ASSIGN SUM_ASSIGN DIFF_ASSIGN MULT_ASSIGN DIVIDE_ASSIGN MOD_ASSIGN }]
}
transition on for_init_part to state [123]
transition on assignment to state [122]
transition on IDENTIFIER to state [100]
transition on variable to state [29]

-------------------
lalr_state [122]: {
  [for_init_part ::= assignment (*) , {SEMICOLON }]
}

-------------------
lalr_state [123]: {
  [loop_stmt ::= FOR LPAREN for_init_part (*) SEMICOLON expr SEMICOLON expr RPAREN block , {IDENTIFIER INT LONG FLOAT DOUBLE BOOL CHAR STRING AUTO IF RETURN BREAK CONTINUE SWITCH END FOR REPEAT FOREACH CONST PRINTLN INPUT }]
  [loop_stmt ::= FOR LPAREN for_init_part (*) SEMICOLON expr SEMICOLON assignment RPAREN block , {IDENTIFIER INT LONG FLOAT DOUBLE BOOL CHAR STRING AUTO IF RETURN BREAK CONTINUE SWITCH END FOR REPEAT FOREACH CONST PRINTLN INPUT }]
  [loop_stmt ::= FOR LPAREN for_init_part (*) SEMICOLON expr SEMICOLON RPAREN block , {IDENTIFIER INT LONG FLOAT DOUBLE BOOL CHAR STRING AUTO IF RETURN BREAK CONTINUE SWITCH END FOR REPEAT FOREACH CONST PRINTLN INPUT }]
}
transition on SEMICOLON to state [124]

-------------------
lalr_state [124]: {
  [expr ::= (*) expr BITWISE_OR expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR }]
  [variable ::= (*) variable LBRACKET expr RBRACKET , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR LBRACKET DOT PLUSPLUS MINUSMINUS }]
  [loop_stmt ::= FOR LPAREN for_init_part SEMICOLON (*) expr SEMICOLON expr RPAREN block , {IDENTIFIER INT LONG FLOAT DOUBLE BOOL CHAR STRING AUTO IF RETURN BREAK CONTINUE SWITCH END FOR REPEAT FOREACH CONST PRINTLN INPUT }]
  [expr ::= (*) variable PLUSPLUS , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR }]
  [expr ::= (*) expr GREATER expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR }]
  [expr ::= (*) expr DIVIDE expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR }]
  [const_val ::= (*) FLOAT_CONST , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR }]
  [expr ::= (*) const_val , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR }]
  [expr ::= (*) variable , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR }]
  [expr ::= (*) expr EQUAL expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR }]
  [variable ::= (*) variable DOT IDENTIFIER , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR LBRACKET DOT PLUSPLUS MINUSMINUS }]
  [loop_stmt ::= FOR LPAREN for_init_part SEMICOLON (*) expr SEMICOLON RPAREN block , {IDENTIFIER INT LONG FLOAT DOUBLE BOOL CHAR STRING AUTO IF RETURN BREAK CONTINUE SWITCH END FOR REPEAT FOREACH CONST PRINTLN INPUT }]
  [expr ::= (*) method_cal , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR }]
  [expr ::= (*) expr LESS expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR }]
  [expr ::= (*) expr MOD expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR }]
  [const_val ::= (*) CHAR_CONST , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR }]
  [expr ::= (*) SIZEOF LPAREN typeName RPAREN , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR }]
  [expr ::= (*) MINUSMINUS variable , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR }]
  [expr ::= (*) expr NOT_EQUAL expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR }]
  [expr ::= (*) expr PLUS expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR }]
  [method_cal ::= (*) IDENTIFIER LPAREN parameters RPAREN , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR }]
  [const_val ::= (*) INT_CONST , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR }]
  [expr ::= (*) MINUS expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR }]
  [expr ::= (*) expr AND expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR }]
  [expr ::= (*) expr BITWISE_AND expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR }]
  [const_val ::= (*) BOOL_CONST , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR }]
  [expr ::= (*) LPAREN base_type RPAREN expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR }]
  [expr ::= (*) PLUSPLUS variable , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR }]
  [expr ::= (*) expr GREATER_EQUAL expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR }]
  [expr ::= (*) expr MINUS expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR }]
  [method_cal ::= (*) INPUT LPAREN typeName RPAREN SEMICOLON , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR }]
  [const_val ::= (*) LONG_CONST , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR }]
  [expr ::= (*) BITWISE_NOT expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR }]
  [expr ::= (*) expr OR expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR }]
  [expr ::= (*) expr BITWISE_XOR expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR }]
  [const_val ::= (*) STRING_CONST , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR }]
  [variable ::= (*) IDENTIFIER , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR LBRACKET DOT PLUSPLUS MINUSMINUS }]
  [loop_stmt ::= FOR LPAREN for_init_part SEMICOLON (*) expr SEMICOLON assignment RPAREN block , {IDENTIFIER INT LONG FLOAT DOUBLE BOOL CHAR STRING AUTO IF RETURN BREAK CONTINUE SWITCH END FOR REPEAT FOREACH CONST PRINTLN INPUT }]
  [expr ::= (*) variable MINUSMINUS , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR }]
  [expr ::= (*) expr LESS_EQUAL expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR }]
  [expr ::= (*) expr MULTIPLY expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR }]
  [method_cal ::= (*) INPUT LPAREN RPAREN SEMICOLON , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR }]
  [const_val ::= (*) DOUBLE_CONST , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR }]
  [expr ::= (*) NOT expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR }]
  [expr ::= (*) LPAREN expr RPAREN , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR }]
}
transition on CHAR_CONST to state [58]
transition on method_cal to state [57]
transition on const_val to state [56]
transition on LONG_CONST to state [55]
transition on FLOAT_CONST to state [54]
transition on variable to state [53]
transition on MINUS to state [52]
transition on PLUSPLUS to state [51]
transition on BITWISE_NOT to state [50]
transition on INT_CONST to state [49]
transition on LPAREN to state [48]
transition on BOOL_CONST to state [47]
transition on MINUSMINUS to state [46]
transition on IDENTIFIER to state [45]
transition on NOT to state [44]
transition on expr to state [125]
transition on DOUBLE_CONST to state [42]
transition on SIZEOF to state [41]
transition on INPUT to state [6]
transition on STRING_CONST to state [40]

-------------------
lalr_state [125]: {
  [expr ::= expr (*) DIVIDE expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR }]
  [expr ::= expr (*) EQUAL expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR }]
  [expr ::= expr (*) LESS expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR }]
  [expr ::= expr (*) MINUS expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR }]
  [expr ::= expr (*) BITWISE_XOR expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR }]
  [expr ::= expr (*) LESS_EQUAL expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR }]
  [loop_stmt ::= FOR LPAREN for_init_part SEMICOLON expr (*) SEMICOLON expr RPAREN block , {IDENTIFIER INT LONG FLOAT DOUBLE BOOL CHAR STRING AUTO IF RETURN BREAK CONTINUE SWITCH END FOR REPEAT FOREACH CONST PRINTLN INPUT }]
  [expr ::= expr (*) MOD expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR }]
  [expr ::= expr (*) NOT_EQUAL expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR }]
  [expr ::= expr (*) AND expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR }]
  [expr ::= expr (*) MULTIPLY expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR }]
  [expr ::= expr (*) BITWISE_OR expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR }]
  [expr ::= expr (*) GREATER expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR }]
  [loop_stmt ::= FOR LPAREN for_init_part SEMICOLON expr (*) SEMICOLON RPAREN block , {IDENTIFIER INT LONG FLOAT DOUBLE BOOL CHAR STRING AUTO IF RETURN BREAK CONTINUE SWITCH END FOR REPEAT FOREACH CONST PRINTLN INPUT }]
  [expr ::= expr (*) PLUS expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR }]
  [expr ::= expr (*) BITWISE_AND expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR }]
  [expr ::= expr (*) GREATER_EQUAL expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR }]
  [expr ::= expr (*) OR expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR }]
  [loop_stmt ::= FOR LPAREN for_init_part SEMICOLON expr (*) SEMICOLON assignment RPAREN block , {IDENTIFIER INT LONG FLOAT DOUBLE BOOL CHAR STRING AUTO IF RETURN BREAK CONTINUE SWITCH END FOR REPEAT FOREACH CONST PRINTLN INPUT }]
}
transition on OR to state [81]
transition on BITWISE_XOR to state [80]
transition on BITWISE_AND to state [79]
transition on GREATER_EQUAL to state [78]
transition on SEMICOLON to state [126]
transition on LESS to state [76]
transition on NOT_EQUAL to state [77]
transition on LESS_EQUAL to state [75]
transition on BITWISE_OR to state [73]
transition on PLUS to state [72]
transition on EQUAL to state [71]
transition on GREATER to state [70]
transition on MOD to state [69]
transition on MULTIPLY to state [68]
transition on DIVIDE to state [67]
transition on MINUS to state [66]
transition on AND to state [65]

-------------------
lalr_state [126]: {
  [expr ::= (*) expr BITWISE_OR expr , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [assignment ::= (*) variable DIVIDE_ASSIGN expr , {RPAREN }]
  [loop_stmt ::= FOR LPAREN for_init_part SEMICOLON expr SEMICOLON (*) expr RPAREN block , {IDENTIFIER INT LONG FLOAT DOUBLE BOOL CHAR STRING AUTO IF RETURN BREAK CONTINUE SWITCH END FOR REPEAT FOREACH CONST PRINTLN INPUT }]
  [variable ::= (*) variable LBRACKET expr RBRACKET , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN LBRACKET DOT PLUSPLUS MINUSMINUS DIRECT_ASSIGN SUM_ASSIGN DIFF_ASSIGN MULT_ASSIGN DIVIDE_ASSIGN MOD_ASSIGN }]
  [expr ::= (*) variable PLUSPLUS , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [expr ::= (*) expr GREATER expr , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [expr ::= (*) expr DIVIDE expr , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [assignment ::= (*) variable DIRECT_ASSIGN expr , {RPAREN }]
  [const_val ::= (*) FLOAT_CONST , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [expr ::= (*) const_val , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [expr ::= (*) variable , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [expr ::= (*) expr EQUAL expr , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [assignment ::= (*) variable MOD_ASSIGN expr , {RPAREN }]
  [loop_stmt ::= FOR LPAREN for_init_part SEMICOLON expr SEMICOLON (*) RPAREN block , {IDENTIFIER INT LONG FLOAT DOUBLE BOOL CHAR STRING AUTO IF RETURN BREAK CONTINUE SWITCH END FOR REPEAT FOREACH CONST PRINTLN INPUT }]
  [variable ::= (*) variable DOT IDENTIFIER , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN LBRACKET DOT PLUSPLUS MINUSMINUS DIRECT_ASSIGN SUM_ASSIGN DIFF_ASSIGN MULT_ASSIGN DIVIDE_ASSIGN MOD_ASSIGN }]
  [expr ::= (*) method_cal , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [expr ::= (*) expr LESS expr , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [expr ::= (*) expr MOD expr , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [assignment ::= (*) variable SUM_ASSIGN expr , {RPAREN }]
  [const_val ::= (*) CHAR_CONST , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [expr ::= (*) SIZEOF LPAREN typeName RPAREN , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [expr ::= (*) MINUSMINUS variable , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [expr ::= (*) expr NOT_EQUAL expr , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [expr ::= (*) expr PLUS expr , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [method_cal ::= (*) IDENTIFIER LPAREN parameters RPAREN , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [const_val ::= (*) INT_CONST , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [expr ::= (*) MINUS expr , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [expr ::= (*) expr AND expr , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [expr ::= (*) expr BITWISE_AND expr , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [assignment ::= (*) variable DIFF_ASSIGN expr , {RPAREN }]
  [const_val ::= (*) BOOL_CONST , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [expr ::= (*) LPAREN base_type RPAREN expr , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [expr ::= (*) PLUSPLUS variable , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [expr ::= (*) expr GREATER_EQUAL expr , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [expr ::= (*) expr MINUS expr , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [method_cal ::= (*) INPUT LPAREN typeName RPAREN SEMICOLON , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [const_val ::= (*) LONG_CONST , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [expr ::= (*) BITWISE_NOT expr , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [expr ::= (*) expr OR expr , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [expr ::= (*) expr BITWISE_XOR expr , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [assignment ::= (*) variable MULT_ASSIGN expr , {RPAREN }]
  [const_val ::= (*) STRING_CONST , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [loop_stmt ::= FOR LPAREN for_init_part SEMICOLON expr SEMICOLON (*) assignment RPAREN block , {IDENTIFIER INT LONG FLOAT DOUBLE BOOL CHAR STRING AUTO IF RETURN BREAK CONTINUE SWITCH END FOR REPEAT FOREACH CONST PRINTLN INPUT }]
  [variable ::= (*) IDENTIFIER , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN LBRACKET DOT PLUSPLUS MINUSMINUS DIRECT_ASSIGN SUM_ASSIGN DIFF_ASSIGN MULT_ASSIGN DIVIDE_ASSIGN MOD_ASSIGN }]
  [expr ::= (*) variable MINUSMINUS , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [expr ::= (*) expr LESS_EQUAL expr , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [expr ::= (*) expr MULTIPLY expr , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [method_cal ::= (*) INPUT LPAREN RPAREN SEMICOLON , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [const_val ::= (*) DOUBLE_CONST , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [expr ::= (*) NOT expr , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [expr ::= (*) LPAREN expr RPAREN , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
}
transition on CHAR_CONST to state [58]
transition on method_cal to state [57]
transition on const_val to state [56]
transition on LONG_CONST to state [55]
transition on FLOAT_CONST to state [54]
transition on variable to state [130]
transition on MINUS to state [52]
transition on PLUSPLUS to state [51]
transition on assignment to state [129]
transition on BITWISE_NOT to state [50]
transition on INT_CONST to state [49]
transition on LPAREN to state [48]
transition on BOOL_CONST to state [47]
transition on MINUSMINUS to state [46]
transition on IDENTIFIER to state [45]
transition on NOT to state [44]
transition on RPAREN to state [128]
transition on expr to state [127]
transition on DOUBLE_CONST to state [42]
transition on SIZEOF to state [41]
transition on INPUT to state [6]
transition on STRING_CONST to state [40]

-------------------
lalr_state [127]: {
  [expr ::= expr (*) BITWISE_OR expr , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [expr ::= expr (*) MOD expr , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [expr ::= expr (*) MINUS expr , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [expr ::= expr (*) OR expr , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [loop_stmt ::= FOR LPAREN for_init_part SEMICOLON expr SEMICOLON expr (*) RPAREN block , {IDENTIFIER INT LONG FLOAT DOUBLE BOOL CHAR STRING AUTO IF RETURN BREAK CONTINUE SWITCH END FOR REPEAT FOREACH CONST PRINTLN INPUT }]
  [expr ::= expr (*) GREATER expr , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [expr ::= expr (*) NOT_EQUAL expr , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [expr ::= expr (*) BITWISE_XOR expr , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [expr ::= expr (*) DIVIDE expr , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [expr ::= expr (*) PLUS expr , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [expr ::= expr (*) AND expr , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [expr ::= expr (*) LESS_EQUAL expr , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [expr ::= expr (*) EQUAL expr , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [expr ::= expr (*) BITWISE_AND expr , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [expr ::= expr (*) MULTIPLY expr , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [expr ::= expr (*) LESS expr , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [expr ::= expr (*) GREATER_EQUAL expr , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
}
transition on OR to state [81]
transition on BITWISE_XOR to state [80]
transition on BITWISE_AND to state [79]
transition on GREATER_EQUAL to state [78]
transition on RPAREN to state [146]
transition on NOT_EQUAL to state [77]
transition on LESS to state [76]
transition on LESS_EQUAL to state [75]
transition on BITWISE_OR to state [73]
transition on PLUS to state [72]
transition on EQUAL to state [71]
transition on GREATER to state [70]
transition on MOD to state [69]
transition on MULTIPLY to state [68]
transition on DIVIDE to state [67]
transition on MINUS to state [66]
transition on AND to state [65]

-------------------
lalr_state [128]: {
  [block ::= (*) BEGIN END , {IDENTIFIER INT LONG FLOAT DOUBLE BOOL CHAR STRING AUTO IF RETURN BREAK CONTINUE SWITCH END FOR REPEAT FOREACH CONST PRINTLN INPUT }]
  [loop_stmt ::= FOR LPAREN for_init_part SEMICOLON expr SEMICOLON RPAREN (*) block , {IDENTIFIER INT LONG FLOAT DOUBLE BOOL CHAR STRING AUTO IF RETURN BREAK CONTINUE SWITCH END FOR REPEAT FOREACH CONST PRINTLN INPUT }]
  [block ::= (*) BEGIN NT$4 block_part NT$5 END , {IDENTIFIER INT LONG FLOAT DOUBLE BOOL CHAR STRING AUTO IF RETURN BREAK CONTINUE SWITCH END FOR REPEAT FOREACH CONST PRINTLN INPUT }]
}
transition on block to state [145]
transition on BEGIN to state [2]

-------------------
lalr_state [129]: {
  [loop_stmt ::= FOR LPAREN for_init_part SEMICOLON expr SEMICOLON assignment (*) RPAREN block , {IDENTIFIER INT LONG FLOAT DOUBLE BOOL CHAR STRING AUTO IF RETURN BREAK CONTINUE SWITCH END FOR REPEAT FOREACH CONST PRINTLN INPUT }]
}
transition on RPAREN to state [143]

-------------------
lalr_state [130]: {
  [assignment ::= variable (*) MOD_ASSIGN expr , {RPAREN }]
  [assignment ::= variable (*) DIFF_ASSIGN expr , {RPAREN }]
  [expr ::= variable (*) PLUSPLUS , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [assignment ::= variable (*) DIVIDE_ASSIGN expr , {RPAREN }]
  [assignment ::= variable (*) SUM_ASSIGN expr , {RPAREN }]
  [expr ::= variable (*) MINUSMINUS , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [expr ::= variable (*) , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [variable ::= variable (*) DOT IDENTIFIER , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN LBRACKET DOT PLUSPLUS MINUSMINUS DIRECT_ASSIGN SUM_ASSIGN DIFF_ASSIGN MULT_ASSIGN DIVIDE_ASSIGN MOD_ASSIGN }]
  [assignment ::= variable (*) MULT_ASSIGN expr , {RPAREN }]
  [assignment ::= variable (*) DIRECT_ASSIGN expr , {RPAREN }]
  [variable ::= variable (*) LBRACKET expr RBRACKET , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN LBRACKET DOT PLUSPLUS MINUSMINUS DIRECT_ASSIGN SUM_ASSIGN DIFF_ASSIGN MULT_ASSIGN DIVIDE_ASSIGN MOD_ASSIGN }]
}
transition on MULT_ASSIGN to state [136]
transition on DIRECT_ASSIGN to state [135]
transition on MINUSMINUS to state [59]
transition on LBRACKET to state [60]
transition on MOD_ASSIGN to state [134]
transition on DOT to state [62]
transition on DIVIDE_ASSIGN to state [133]
transition on SUM_ASSIGN to state [132]
transition on DIFF_ASSIGN to state [131]
transition on PLUSPLUS to state [61]

-------------------
lalr_state [131]: {
  [expr ::= (*) expr BITWISE_OR expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [variable ::= (*) variable LBRACKET expr RBRACKET , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN LBRACKET DOT PLUSPLUS MINUSMINUS }]
  [expr ::= (*) variable PLUSPLUS , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [expr ::= (*) expr GREATER expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [expr ::= (*) expr DIVIDE expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [const_val ::= (*) FLOAT_CONST , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [expr ::= (*) const_val , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [expr ::= (*) variable , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [expr ::= (*) expr EQUAL expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [variable ::= (*) variable DOT IDENTIFIER , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN LBRACKET DOT PLUSPLUS MINUSMINUS }]
  [expr ::= (*) method_cal , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [expr ::= (*) expr LESS expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [expr ::= (*) expr MOD expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [const_val ::= (*) CHAR_CONST , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [expr ::= (*) SIZEOF LPAREN typeName RPAREN , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [expr ::= (*) MINUSMINUS variable , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [expr ::= (*) expr NOT_EQUAL expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [expr ::= (*) expr PLUS expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [method_cal ::= (*) IDENTIFIER LPAREN parameters RPAREN , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [const_val ::= (*) INT_CONST , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [expr ::= (*) MINUS expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [expr ::= (*) expr AND expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [expr ::= (*) expr BITWISE_AND expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [assignment ::= variable DIFF_ASSIGN (*) expr , {SEMICOLON RPAREN }]
  [const_val ::= (*) BOOL_CONST , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [expr ::= (*) LPAREN base_type RPAREN expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [expr ::= (*) PLUSPLUS variable , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [expr ::= (*) expr GREATER_EQUAL expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [expr ::= (*) expr MINUS expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [method_cal ::= (*) INPUT LPAREN typeName RPAREN SEMICOLON , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [const_val ::= (*) LONG_CONST , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [expr ::= (*) BITWISE_NOT expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [expr ::= (*) expr OR expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [expr ::= (*) expr BITWISE_XOR expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [const_val ::= (*) STRING_CONST , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [variable ::= (*) IDENTIFIER , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN LBRACKET DOT PLUSPLUS MINUSMINUS }]
  [expr ::= (*) variable MINUSMINUS , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [expr ::= (*) expr LESS_EQUAL expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [expr ::= (*) expr MULTIPLY expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [method_cal ::= (*) INPUT LPAREN RPAREN SEMICOLON , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [const_val ::= (*) DOUBLE_CONST , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [expr ::= (*) NOT expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [expr ::= (*) LPAREN expr RPAREN , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
}
transition on CHAR_CONST to state [58]
transition on method_cal to state [57]
transition on const_val to state [56]
transition on LONG_CONST to state [55]
transition on FLOAT_CONST to state [54]
transition on variable to state [53]
transition on MINUS to state [52]
transition on PLUSPLUS to state [51]
transition on BITWISE_NOT to state [50]
transition on INT_CONST to state [49]
transition on LPAREN to state [48]
transition on BOOL_CONST to state [47]
transition on MINUSMINUS to state [46]
transition on IDENTIFIER to state [45]
transition on NOT to state [44]
transition on expr to state [142]
transition on DOUBLE_CONST to state [42]
transition on SIZEOF to state [41]
transition on INPUT to state [6]
transition on STRING_CONST to state [40]

-------------------
lalr_state [132]: {
  [expr ::= (*) expr BITWISE_OR expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [variable ::= (*) variable LBRACKET expr RBRACKET , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN LBRACKET DOT PLUSPLUS MINUSMINUS }]
  [expr ::= (*) variable PLUSPLUS , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [expr ::= (*) expr GREATER expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [expr ::= (*) expr DIVIDE expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [const_val ::= (*) FLOAT_CONST , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [expr ::= (*) const_val , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [expr ::= (*) variable , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [expr ::= (*) expr EQUAL expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [variable ::= (*) variable DOT IDENTIFIER , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN LBRACKET DOT PLUSPLUS MINUSMINUS }]
  [expr ::= (*) method_cal , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [expr ::= (*) expr LESS expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [expr ::= (*) expr MOD expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [assignment ::= variable SUM_ASSIGN (*) expr , {SEMICOLON RPAREN }]
  [const_val ::= (*) CHAR_CONST , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [expr ::= (*) SIZEOF LPAREN typeName RPAREN , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [expr ::= (*) MINUSMINUS variable , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [expr ::= (*) expr NOT_EQUAL expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [expr ::= (*) expr PLUS expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [method_cal ::= (*) IDENTIFIER LPAREN parameters RPAREN , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [const_val ::= (*) INT_CONST , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [expr ::= (*) MINUS expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [expr ::= (*) expr AND expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [expr ::= (*) expr BITWISE_AND expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [const_val ::= (*) BOOL_CONST , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [expr ::= (*) LPAREN base_type RPAREN expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [expr ::= (*) PLUSPLUS variable , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [expr ::= (*) expr GREATER_EQUAL expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [expr ::= (*) expr MINUS expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [method_cal ::= (*) INPUT LPAREN typeName RPAREN SEMICOLON , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [const_val ::= (*) LONG_CONST , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [expr ::= (*) BITWISE_NOT expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [expr ::= (*) expr OR expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [expr ::= (*) expr BITWISE_XOR expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [const_val ::= (*) STRING_CONST , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [variable ::= (*) IDENTIFIER , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN LBRACKET DOT PLUSPLUS MINUSMINUS }]
  [expr ::= (*) variable MINUSMINUS , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [expr ::= (*) expr LESS_EQUAL expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [expr ::= (*) expr MULTIPLY expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [method_cal ::= (*) INPUT LPAREN RPAREN SEMICOLON , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [const_val ::= (*) DOUBLE_CONST , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [expr ::= (*) NOT expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [expr ::= (*) LPAREN expr RPAREN , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
}
transition on CHAR_CONST to state [58]
transition on method_cal to state [57]
transition on const_val to state [56]
transition on LONG_CONST to state [55]
transition on FLOAT_CONST to state [54]
transition on variable to state [53]
transition on MINUS to state [52]
transition on PLUSPLUS to state [51]
transition on BITWISE_NOT to state [50]
transition on INT_CONST to state [49]
transition on LPAREN to state [48]
transition on BOOL_CONST to state [47]
transition on MINUSMINUS to state [46]
transition on IDENTIFIER to state [45]
transition on NOT to state [44]
transition on expr to state [141]
transition on DOUBLE_CONST to state [42]
transition on SIZEOF to state [41]
transition on INPUT to state [6]
transition on STRING_CONST to state [40]

-------------------
lalr_state [133]: {
  [expr ::= (*) expr BITWISE_OR expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [assignment ::= variable DIVIDE_ASSIGN (*) expr , {SEMICOLON RPAREN }]
  [variable ::= (*) variable LBRACKET expr RBRACKET , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN LBRACKET DOT PLUSPLUS MINUSMINUS }]
  [expr ::= (*) variable PLUSPLUS , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [expr ::= (*) expr GREATER expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [expr ::= (*) expr DIVIDE expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [const_val ::= (*) FLOAT_CONST , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [expr ::= (*) const_val , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [expr ::= (*) variable , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [expr ::= (*) expr EQUAL expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [variable ::= (*) variable DOT IDENTIFIER , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN LBRACKET DOT PLUSPLUS MINUSMINUS }]
  [expr ::= (*) method_cal , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [expr ::= (*) expr LESS expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [expr ::= (*) expr MOD expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [const_val ::= (*) CHAR_CONST , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [expr ::= (*) SIZEOF LPAREN typeName RPAREN , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [expr ::= (*) MINUSMINUS variable , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [expr ::= (*) expr NOT_EQUAL expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [expr ::= (*) expr PLUS expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [method_cal ::= (*) IDENTIFIER LPAREN parameters RPAREN , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [const_val ::= (*) INT_CONST , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [expr ::= (*) MINUS expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [expr ::= (*) expr AND expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [expr ::= (*) expr BITWISE_AND expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [const_val ::= (*) BOOL_CONST , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [expr ::= (*) LPAREN base_type RPAREN expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [expr ::= (*) PLUSPLUS variable , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [expr ::= (*) expr GREATER_EQUAL expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [expr ::= (*) expr MINUS expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [method_cal ::= (*) INPUT LPAREN typeName RPAREN SEMICOLON , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [const_val ::= (*) LONG_CONST , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [expr ::= (*) BITWISE_NOT expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [expr ::= (*) expr OR expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [expr ::= (*) expr BITWISE_XOR expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [const_val ::= (*) STRING_CONST , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [variable ::= (*) IDENTIFIER , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN LBRACKET DOT PLUSPLUS MINUSMINUS }]
  [expr ::= (*) variable MINUSMINUS , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [expr ::= (*) expr LESS_EQUAL expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [expr ::= (*) expr MULTIPLY expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [method_cal ::= (*) INPUT LPAREN RPAREN SEMICOLON , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [const_val ::= (*) DOUBLE_CONST , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [expr ::= (*) NOT expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [expr ::= (*) LPAREN expr RPAREN , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
}
transition on CHAR_CONST to state [58]
transition on method_cal to state [57]
transition on const_val to state [56]
transition on LONG_CONST to state [55]
transition on FLOAT_CONST to state [54]
transition on variable to state [53]
transition on MINUS to state [52]
transition on PLUSPLUS to state [51]
transition on BITWISE_NOT to state [50]
transition on INT_CONST to state [49]
transition on LPAREN to state [48]
transition on BOOL_CONST to state [47]
transition on MINUSMINUS to state [46]
transition on IDENTIFIER to state [45]
transition on NOT to state [44]
transition on expr to state [140]
transition on DOUBLE_CONST to state [42]
transition on SIZEOF to state [41]
transition on INPUT to state [6]
transition on STRING_CONST to state [40]

-------------------
lalr_state [134]: {
  [expr ::= (*) expr BITWISE_OR expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [variable ::= (*) variable LBRACKET expr RBRACKET , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN LBRACKET DOT PLUSPLUS MINUSMINUS }]
  [expr ::= (*) variable PLUSPLUS , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [expr ::= (*) expr GREATER expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [expr ::= (*) expr DIVIDE expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [const_val ::= (*) FLOAT_CONST , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [expr ::= (*) const_val , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [expr ::= (*) variable , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [expr ::= (*) expr EQUAL expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [assignment ::= variable MOD_ASSIGN (*) expr , {SEMICOLON RPAREN }]
  [variable ::= (*) variable DOT IDENTIFIER , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN LBRACKET DOT PLUSPLUS MINUSMINUS }]
  [expr ::= (*) method_cal , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [expr ::= (*) expr LESS expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [expr ::= (*) expr MOD expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [const_val ::= (*) CHAR_CONST , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [expr ::= (*) SIZEOF LPAREN typeName RPAREN , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [expr ::= (*) MINUSMINUS variable , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [expr ::= (*) expr NOT_EQUAL expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [expr ::= (*) expr PLUS expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [method_cal ::= (*) IDENTIFIER LPAREN parameters RPAREN , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [const_val ::= (*) INT_CONST , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [expr ::= (*) MINUS expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [expr ::= (*) expr AND expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [expr ::= (*) expr BITWISE_AND expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [const_val ::= (*) BOOL_CONST , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [expr ::= (*) LPAREN base_type RPAREN expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [expr ::= (*) PLUSPLUS variable , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [expr ::= (*) expr GREATER_EQUAL expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [expr ::= (*) expr MINUS expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [method_cal ::= (*) INPUT LPAREN typeName RPAREN SEMICOLON , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [const_val ::= (*) LONG_CONST , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [expr ::= (*) BITWISE_NOT expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [expr ::= (*) expr OR expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [expr ::= (*) expr BITWISE_XOR expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [const_val ::= (*) STRING_CONST , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [variable ::= (*) IDENTIFIER , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN LBRACKET DOT PLUSPLUS MINUSMINUS }]
  [expr ::= (*) variable MINUSMINUS , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [expr ::= (*) expr LESS_EQUAL expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [expr ::= (*) expr MULTIPLY expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [method_cal ::= (*) INPUT LPAREN RPAREN SEMICOLON , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [const_val ::= (*) DOUBLE_CONST , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [expr ::= (*) NOT expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [expr ::= (*) LPAREN expr RPAREN , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
}
transition on CHAR_CONST to state [58]
transition on method_cal to state [57]
transition on const_val to state [56]
transition on LONG_CONST to state [55]
transition on FLOAT_CONST to state [54]
transition on variable to state [53]
transition on MINUS to state [52]
transition on PLUSPLUS to state [51]
transition on BITWISE_NOT to state [50]
transition on INT_CONST to state [49]
transition on LPAREN to state [48]
transition on BOOL_CONST to state [47]
transition on MINUSMINUS to state [46]
transition on IDENTIFIER to state [45]
transition on NOT to state [44]
transition on expr to state [139]
transition on DOUBLE_CONST to state [42]
transition on SIZEOF to state [41]
transition on INPUT to state [6]
transition on STRING_CONST to state [40]

-------------------
lalr_state [135]: {
  [expr ::= (*) expr BITWISE_OR expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [variable ::= (*) variable LBRACKET expr RBRACKET , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN LBRACKET DOT PLUSPLUS MINUSMINUS }]
  [expr ::= (*) variable PLUSPLUS , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [expr ::= (*) expr GREATER expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [expr ::= (*) expr DIVIDE expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [assignment ::= variable DIRECT_ASSIGN (*) expr , {SEMICOLON RPAREN }]
  [const_val ::= (*) FLOAT_CONST , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [expr ::= (*) const_val , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [expr ::= (*) variable , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [expr ::= (*) expr EQUAL expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [variable ::= (*) variable DOT IDENTIFIER , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN LBRACKET DOT PLUSPLUS MINUSMINUS }]
  [expr ::= (*) method_cal , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [expr ::= (*) expr LESS expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [expr ::= (*) expr MOD expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [const_val ::= (*) CHAR_CONST , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [expr ::= (*) SIZEOF LPAREN typeName RPAREN , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [expr ::= (*) MINUSMINUS variable , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [expr ::= (*) expr NOT_EQUAL expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [expr ::= (*) expr PLUS expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [method_cal ::= (*) IDENTIFIER LPAREN parameters RPAREN , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [const_val ::= (*) INT_CONST , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [expr ::= (*) MINUS expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [expr ::= (*) expr AND expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [expr ::= (*) expr BITWISE_AND expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [const_val ::= (*) BOOL_CONST , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [expr ::= (*) LPAREN base_type RPAREN expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [expr ::= (*) PLUSPLUS variable , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [expr ::= (*) expr GREATER_EQUAL expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [expr ::= (*) expr MINUS expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [method_cal ::= (*) INPUT LPAREN typeName RPAREN SEMICOLON , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [const_val ::= (*) LONG_CONST , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [expr ::= (*) BITWISE_NOT expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [expr ::= (*) expr OR expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [expr ::= (*) expr BITWISE_XOR expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [const_val ::= (*) STRING_CONST , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [variable ::= (*) IDENTIFIER , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN LBRACKET DOT PLUSPLUS MINUSMINUS }]
  [expr ::= (*) variable MINUSMINUS , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [expr ::= (*) expr LESS_EQUAL expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [expr ::= (*) expr MULTIPLY expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [method_cal ::= (*) INPUT LPAREN RPAREN SEMICOLON , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [const_val ::= (*) DOUBLE_CONST , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [expr ::= (*) NOT expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [expr ::= (*) LPAREN expr RPAREN , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
}
transition on CHAR_CONST to state [58]
transition on method_cal to state [57]
transition on const_val to state [56]
transition on LONG_CONST to state [55]
transition on FLOAT_CONST to state [54]
transition on variable to state [53]
transition on MINUS to state [52]
transition on PLUSPLUS to state [51]
transition on BITWISE_NOT to state [50]
transition on INT_CONST to state [49]
transition on LPAREN to state [48]
transition on BOOL_CONST to state [47]
transition on MINUSMINUS to state [46]
transition on IDENTIFIER to state [45]
transition on NOT to state [44]
transition on expr to state [138]
transition on DOUBLE_CONST to state [42]
transition on SIZEOF to state [41]
transition on INPUT to state [6]
transition on STRING_CONST to state [40]

-------------------
lalr_state [136]: {
  [expr ::= (*) expr BITWISE_OR expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [variable ::= (*) variable LBRACKET expr RBRACKET , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN LBRACKET DOT PLUSPLUS MINUSMINUS }]
  [expr ::= (*) variable PLUSPLUS , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [expr ::= (*) expr GREATER expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [expr ::= (*) expr DIVIDE expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [const_val ::= (*) FLOAT_CONST , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [expr ::= (*) const_val , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [expr ::= (*) variable , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [expr ::= (*) expr EQUAL expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [variable ::= (*) variable DOT IDENTIFIER , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN LBRACKET DOT PLUSPLUS MINUSMINUS }]
  [expr ::= (*) method_cal , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [expr ::= (*) expr LESS expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [expr ::= (*) expr MOD expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [const_val ::= (*) CHAR_CONST , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [expr ::= (*) SIZEOF LPAREN typeName RPAREN , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [expr ::= (*) MINUSMINUS variable , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [expr ::= (*) expr NOT_EQUAL expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [expr ::= (*) expr PLUS expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [method_cal ::= (*) IDENTIFIER LPAREN parameters RPAREN , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [const_val ::= (*) INT_CONST , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [expr ::= (*) MINUS expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [expr ::= (*) expr AND expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [expr ::= (*) expr BITWISE_AND expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [const_val ::= (*) BOOL_CONST , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [expr ::= (*) LPAREN base_type RPAREN expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [expr ::= (*) PLUSPLUS variable , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [expr ::= (*) expr GREATER_EQUAL expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [expr ::= (*) expr MINUS expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [method_cal ::= (*) INPUT LPAREN typeName RPAREN SEMICOLON , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [const_val ::= (*) LONG_CONST , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [expr ::= (*) BITWISE_NOT expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [expr ::= (*) expr OR expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [expr ::= (*) expr BITWISE_XOR expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [assignment ::= variable MULT_ASSIGN (*) expr , {SEMICOLON RPAREN }]
  [const_val ::= (*) STRING_CONST , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [variable ::= (*) IDENTIFIER , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN LBRACKET DOT PLUSPLUS MINUSMINUS }]
  [expr ::= (*) variable MINUSMINUS , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [expr ::= (*) expr LESS_EQUAL expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [expr ::= (*) expr MULTIPLY expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [method_cal ::= (*) INPUT LPAREN RPAREN SEMICOLON , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [const_val ::= (*) DOUBLE_CONST , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [expr ::= (*) NOT expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [expr ::= (*) LPAREN expr RPAREN , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
}
transition on CHAR_CONST to state [58]
transition on method_cal to state [57]
transition on const_val to state [56]
transition on LONG_CONST to state [55]
transition on FLOAT_CONST to state [54]
transition on variable to state [53]
transition on MINUS to state [52]
transition on PLUSPLUS to state [51]
transition on BITWISE_NOT to state [50]
transition on INT_CONST to state [49]
transition on LPAREN to state [48]
transition on BOOL_CONST to state [47]
transition on MINUSMINUS to state [46]
transition on IDENTIFIER to state [45]
transition on NOT to state [44]
transition on expr to state [137]
transition on DOUBLE_CONST to state [42]
transition on SIZEOF to state [41]
transition on INPUT to state [6]
transition on STRING_CONST to state [40]

-------------------
lalr_state [137]: {
  [expr ::= expr (*) BITWISE_OR expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [expr ::= expr (*) MOD expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [expr ::= expr (*) MINUS expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [expr ::= expr (*) OR expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [expr ::= expr (*) GREATER expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [expr ::= expr (*) NOT_EQUAL expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [expr ::= expr (*) BITWISE_XOR expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [expr ::= expr (*) DIVIDE expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [expr ::= expr (*) PLUS expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [expr ::= expr (*) AND expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [expr ::= expr (*) LESS_EQUAL expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [assignment ::= variable MULT_ASSIGN expr (*) , {SEMICOLON RPAREN }]
  [expr ::= expr (*) EQUAL expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [expr ::= expr (*) BITWISE_AND expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [expr ::= expr (*) MULTIPLY expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [expr ::= expr (*) LESS expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [expr ::= expr (*) GREATER_EQUAL expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
}
transition on OR to state [81]
transition on BITWISE_XOR to state [80]
transition on BITWISE_AND to state [79]
transition on GREATER_EQUAL to state [78]
transition on NOT_EQUAL to state [77]
transition on LESS to state [76]
transition on LESS_EQUAL to state [75]
transition on BITWISE_OR to state [73]
transition on PLUS to state [72]
transition on EQUAL to state [71]
transition on GREATER to state [70]
transition on MOD to state [69]
transition on MULTIPLY to state [68]
transition on DIVIDE to state [67]
transition on MINUS to state [66]
transition on AND to state [65]

-------------------
lalr_state [138]: {
  [expr ::= expr (*) BITWISE_OR expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [expr ::= expr (*) MOD expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [expr ::= expr (*) MINUS expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [expr ::= expr (*) OR expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [expr ::= expr (*) GREATER expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [expr ::= expr (*) NOT_EQUAL expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [expr ::= expr (*) BITWISE_XOR expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [expr ::= expr (*) DIVIDE expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [expr ::= expr (*) PLUS expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [expr ::= expr (*) AND expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [expr ::= expr (*) LESS_EQUAL expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [expr ::= expr (*) EQUAL expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [expr ::= expr (*) BITWISE_AND expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [assignment ::= variable DIRECT_ASSIGN expr (*) , {SEMICOLON RPAREN }]
  [expr ::= expr (*) MULTIPLY expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [expr ::= expr (*) LESS expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [expr ::= expr (*) GREATER_EQUAL expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
}
transition on OR to state [81]
transition on BITWISE_XOR to state [80]
transition on BITWISE_AND to state [79]
transition on GREATER_EQUAL to state [78]
transition on NOT_EQUAL to state [77]
transition on LESS to state [76]
transition on LESS_EQUAL to state [75]
transition on BITWISE_OR to state [73]
transition on PLUS to state [72]
transition on EQUAL to state [71]
transition on GREATER to state [70]
transition on MOD to state [69]
transition on MULTIPLY to state [68]
transition on DIVIDE to state [67]
transition on MINUS to state [66]
transition on AND to state [65]

-------------------
lalr_state [139]: {
  [expr ::= expr (*) BITWISE_OR expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [expr ::= expr (*) MOD expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [expr ::= expr (*) MINUS expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [expr ::= expr (*) OR expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [expr ::= expr (*) GREATER expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [expr ::= expr (*) NOT_EQUAL expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [expr ::= expr (*) BITWISE_XOR expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [expr ::= expr (*) DIVIDE expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [expr ::= expr (*) PLUS expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [expr ::= expr (*) AND expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [expr ::= expr (*) LESS_EQUAL expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [expr ::= expr (*) EQUAL expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [expr ::= expr (*) BITWISE_AND expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [expr ::= expr (*) MULTIPLY expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [expr ::= expr (*) LESS expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [expr ::= expr (*) GREATER_EQUAL expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [assignment ::= variable MOD_ASSIGN expr (*) , {SEMICOLON RPAREN }]
}
transition on OR to state [81]
transition on BITWISE_XOR to state [80]
transition on BITWISE_AND to state [79]
transition on GREATER_EQUAL to state [78]
transition on NOT_EQUAL to state [77]
transition on LESS to state [76]
transition on LESS_EQUAL to state [75]
transition on BITWISE_OR to state [73]
transition on PLUS to state [72]
transition on EQUAL to state [71]
transition on GREATER to state [70]
transition on MOD to state [69]
transition on MULTIPLY to state [68]
transition on DIVIDE to state [67]
transition on MINUS to state [66]
transition on AND to state [65]

-------------------
lalr_state [140]: {
  [expr ::= expr (*) BITWISE_OR expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [expr ::= expr (*) MOD expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [expr ::= expr (*) MINUS expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [expr ::= expr (*) OR expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [expr ::= expr (*) GREATER expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [expr ::= expr (*) NOT_EQUAL expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [assignment ::= variable DIVIDE_ASSIGN expr (*) , {SEMICOLON RPAREN }]
  [expr ::= expr (*) BITWISE_XOR expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [expr ::= expr (*) DIVIDE expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [expr ::= expr (*) PLUS expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [expr ::= expr (*) AND expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [expr ::= expr (*) LESS_EQUAL expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [expr ::= expr (*) EQUAL expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [expr ::= expr (*) BITWISE_AND expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [expr ::= expr (*) MULTIPLY expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [expr ::= expr (*) LESS expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [expr ::= expr (*) GREATER_EQUAL expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
}
transition on OR to state [81]
transition on BITWISE_XOR to state [80]
transition on BITWISE_AND to state [79]
transition on GREATER_EQUAL to state [78]
transition on NOT_EQUAL to state [77]
transition on LESS to state [76]
transition on LESS_EQUAL to state [75]
transition on BITWISE_OR to state [73]
transition on PLUS to state [72]
transition on EQUAL to state [71]
transition on GREATER to state [70]
transition on MOD to state [69]
transition on MULTIPLY to state [68]
transition on DIVIDE to state [67]
transition on MINUS to state [66]
transition on AND to state [65]

-------------------
lalr_state [141]: {
  [expr ::= expr (*) BITWISE_OR expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [expr ::= expr (*) MOD expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [expr ::= expr (*) MINUS expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [expr ::= expr (*) OR expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [expr ::= expr (*) GREATER expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [expr ::= expr (*) NOT_EQUAL expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [expr ::= expr (*) BITWISE_XOR expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [assignment ::= variable SUM_ASSIGN expr (*) , {SEMICOLON RPAREN }]
  [expr ::= expr (*) DIVIDE expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [expr ::= expr (*) PLUS expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [expr ::= expr (*) AND expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [expr ::= expr (*) LESS_EQUAL expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [expr ::= expr (*) EQUAL expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [expr ::= expr (*) BITWISE_AND expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [expr ::= expr (*) MULTIPLY expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [expr ::= expr (*) LESS expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [expr ::= expr (*) GREATER_EQUAL expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
}
transition on OR to state [81]
transition on BITWISE_XOR to state [80]
transition on BITWISE_AND to state [79]
transition on GREATER_EQUAL to state [78]
transition on NOT_EQUAL to state [77]
transition on LESS to state [76]
transition on LESS_EQUAL to state [75]
transition on BITWISE_OR to state [73]
transition on PLUS to state [72]
transition on EQUAL to state [71]
transition on GREATER to state [70]
transition on MOD to state [69]
transition on MULTIPLY to state [68]
transition on DIVIDE to state [67]
transition on MINUS to state [66]
transition on AND to state [65]

-------------------
lalr_state [142]: {
  [assignment ::= variable DIFF_ASSIGN expr (*) , {SEMICOLON RPAREN }]
  [expr ::= expr (*) BITWISE_OR expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [expr ::= expr (*) MOD expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [expr ::= expr (*) MINUS expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [expr ::= expr (*) OR expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [expr ::= expr (*) GREATER expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [expr ::= expr (*) NOT_EQUAL expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [expr ::= expr (*) BITWISE_XOR expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [expr ::= expr (*) DIVIDE expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [expr ::= expr (*) PLUS expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [expr ::= expr (*) AND expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [expr ::= expr (*) LESS_EQUAL expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [expr ::= expr (*) EQUAL expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [expr ::= expr (*) BITWISE_AND expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [expr ::= expr (*) MULTIPLY expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [expr ::= expr (*) LESS expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [expr ::= expr (*) GREATER_EQUAL expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
}
transition on OR to state [81]
transition on BITWISE_XOR to state [80]
transition on BITWISE_AND to state [79]
transition on GREATER_EQUAL to state [78]
transition on NOT_EQUAL to state [77]
transition on LESS to state [76]
transition on LESS_EQUAL to state [75]
transition on BITWISE_OR to state [73]
transition on PLUS to state [72]
transition on EQUAL to state [71]
transition on GREATER to state [70]
transition on MOD to state [69]
transition on MULTIPLY to state [68]
transition on DIVIDE to state [67]
transition on MINUS to state [66]
transition on AND to state [65]

-------------------
lalr_state [143]: {
  [loop_stmt ::= FOR LPAREN for_init_part SEMICOLON expr SEMICOLON assignment RPAREN (*) block , {IDENTIFIER INT LONG FLOAT DOUBLE BOOL CHAR STRING AUTO IF RETURN BREAK CONTINUE SWITCH END FOR REPEAT FOREACH CONST PRINTLN INPUT }]
  [block ::= (*) BEGIN END , {IDENTIFIER INT LONG FLOAT DOUBLE BOOL CHAR STRING AUTO IF RETURN BREAK CONTINUE SWITCH END FOR REPEAT FOREACH CONST PRINTLN INPUT }]
  [block ::= (*) BEGIN NT$4 block_part NT$5 END , {IDENTIFIER INT LONG FLOAT DOUBLE BOOL CHAR STRING AUTO IF RETURN BREAK CONTINUE SWITCH END FOR REPEAT FOREACH CONST PRINTLN INPUT }]
}
transition on block to state [144]
transition on BEGIN to state [2]

-------------------
lalr_state [144]: {
  [loop_stmt ::= FOR LPAREN for_init_part SEMICOLON expr SEMICOLON assignment RPAREN block (*) , {IDENTIFIER INT LONG FLOAT DOUBLE BOOL CHAR STRING AUTO IF RETURN BREAK CONTINUE SWITCH END FOR REPEAT FOREACH CONST PRINTLN INPUT }]
}

-------------------
lalr_state [145]: {
  [loop_stmt ::= FOR LPAREN for_init_part SEMICOLON expr SEMICOLON RPAREN block (*) , {IDENTIFIER INT LONG FLOAT DOUBLE BOOL CHAR STRING AUTO IF RETURN BREAK CONTINUE SWITCH END FOR REPEAT FOREACH CONST PRINTLN INPUT }]
}

-------------------
lalr_state [146]: {
  [block ::= (*) BEGIN END , {IDENTIFIER INT LONG FLOAT DOUBLE BOOL CHAR STRING AUTO IF RETURN BREAK CONTINUE SWITCH END FOR REPEAT FOREACH CONST PRINTLN INPUT }]
  [loop_stmt ::= FOR LPAREN for_init_part SEMICOLON expr SEMICOLON expr RPAREN (*) block , {IDENTIFIER INT LONG FLOAT DOUBLE BOOL CHAR STRING AUTO IF RETURN BREAK CONTINUE SWITCH END FOR REPEAT FOREACH CONST PRINTLN INPUT }]
  [block ::= (*) BEGIN NT$4 block_part NT$5 END , {IDENTIFIER INT LONG FLOAT DOUBLE BOOL CHAR STRING AUTO IF RETURN BREAK CONTINUE SWITCH END FOR REPEAT FOREACH CONST PRINTLN INPUT }]
}
transition on block to state [147]
transition on BEGIN to state [2]

-------------------
lalr_state [147]: {
  [loop_stmt ::= FOR LPAREN for_init_part SEMICOLON expr SEMICOLON expr RPAREN block (*) , {IDENTIFIER INT LONG FLOAT DOUBLE BOOL CHAR STRING AUTO IF RETURN BREAK CONTINUE SWITCH END FOR REPEAT FOREACH CONST PRINTLN INPUT }]
}

-------------------
lalr_state [148]: {
  [block_body ::= method_cal SEMICOLON (*) , {IDENTIFIER INT LONG FLOAT DOUBLE BOOL CHAR STRING AUTO IF RETURN BREAK CONTINUE SWITCH END FOR REPEAT FOREACH CONST PRINTLN INPUT }]
}

-------------------
lalr_state [149]: {
  [array_part_no_val ::= (*) , {IDENTIFIER }]
  [var_dcl ::= CONST typeName (*) array_part_no_val NT$0 const_var_dcl_p SEMICOLON , {IDENTIFIER INT LONG FLOAT DOUBLE BOOL CHAR STRING AUTO IF RETURN BREAK CONTINUE SWITCH END FOR REPEAT FOREACH CONST PRINTLN INPUT }]
  [array_part_no_val ::= (*) LRBRACKET array_part_no_val , {IDENTIFIER }]
}
transition on LRBRACKET to state [160]
transition on array_part_no_val to state [159]

-------------------
lalr_state [150]: {
  [NT$2 ::= (*) , {IDENTIFIER }]
  [var_dcl ::= CONST AUTO (*) NT$2 const_var_dcl_p SEMICOLON , {IDENTIFIER INT LONG FLOAT DOUBLE BOOL CHAR STRING AUTO IF RETURN BREAK CONTINUE SWITCH END FOR REPEAT FOREACH CONST PRINTLN INPUT }]
}
transition on NT$2 to state [151]

-------------------
lalr_state [151]: {
  [const_var_dcl_p ::= (*) IDENTIFIER DIRECT_ASSIGN expr COMMA const_var_dcl_p , {SEMICOLON }]
  [const_var_dcl_p ::= (*) IDENTIFIER DIRECT_ASSIGN expr , {SEMICOLON }]
  [var_dcl ::= CONST AUTO NT$2 (*) const_var_dcl_p SEMICOLON , {IDENTIFIER INT LONG FLOAT DOUBLE BOOL CHAR STRING AUTO IF RETURN BREAK CONTINUE SWITCH END FOR REPEAT FOREACH CONST PRINTLN INPUT }]
}
transition on const_var_dcl_p to state [153]
transition on IDENTIFIER to state [152]

-------------------
lalr_state [152]: {
  [const_var_dcl_p ::= IDENTIFIER (*) DIRECT_ASSIGN expr , {SEMICOLON }]
  [const_var_dcl_p ::= IDENTIFIER (*) DIRECT_ASSIGN expr COMMA const_var_dcl_p , {SEMICOLON }]
}
transition on DIRECT_ASSIGN to state [155]

-------------------
lalr_state [153]: {
  [var_dcl ::= CONST AUTO NT$2 const_var_dcl_p (*) SEMICOLON , {IDENTIFIER INT LONG FLOAT DOUBLE BOOL CHAR STRING AUTO IF RETURN BREAK CONTINUE SWITCH END FOR REPEAT FOREACH CONST PRINTLN INPUT }]
}
transition on SEMICOLON to state [154]

-------------------
lalr_state [154]: {
  [var_dcl ::= CONST AUTO NT$2 const_var_dcl_p SEMICOLON (*) , {IDENTIFIER INT LONG FLOAT DOUBLE BOOL CHAR STRING AUTO IF RETURN BREAK CONTINUE SWITCH END FOR REPEAT FOREACH CONST PRINTLN INPUT }]
}

-------------------
lalr_state [155]: {
  [expr ::= (*) expr BITWISE_OR expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR COMMA }]
  [variable ::= (*) variable LBRACKET expr RBRACKET , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR LBRACKET DOT COMMA PLUSPLUS MINUSMINUS }]
  [expr ::= (*) variable PLUSPLUS , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR COMMA }]
  [expr ::= (*) expr GREATER expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR COMMA }]
  [expr ::= (*) expr DIVIDE expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR COMMA }]
  [const_val ::= (*) FLOAT_CONST , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR COMMA }]
  [expr ::= (*) const_val , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR COMMA }]
  [expr ::= (*) variable , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR COMMA }]
  [expr ::= (*) expr EQUAL expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR COMMA }]
  [variable ::= (*) variable DOT IDENTIFIER , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR LBRACKET DOT COMMA PLUSPLUS MINUSMINUS }]
  [expr ::= (*) method_cal , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR COMMA }]
  [expr ::= (*) expr LESS expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR COMMA }]
  [expr ::= (*) expr MOD expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR COMMA }]
  [const_val ::= (*) CHAR_CONST , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR COMMA }]
  [expr ::= (*) SIZEOF LPAREN typeName RPAREN , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR COMMA }]
  [expr ::= (*) MINUSMINUS variable , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR COMMA }]
  [expr ::= (*) expr NOT_EQUAL expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR COMMA }]
  [expr ::= (*) expr PLUS expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR COMMA }]
  [method_cal ::= (*) IDENTIFIER LPAREN parameters RPAREN , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR COMMA }]
  [const_val ::= (*) INT_CONST , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR COMMA }]
  [expr ::= (*) MINUS expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR COMMA }]
  [expr ::= (*) expr AND expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR COMMA }]
  [expr ::= (*) expr BITWISE_AND expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR COMMA }]
  [const_var_dcl_p ::= IDENTIFIER DIRECT_ASSIGN (*) expr COMMA const_var_dcl_p , {SEMICOLON }]
  [const_val ::= (*) BOOL_CONST , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR COMMA }]
  [expr ::= (*) LPAREN base_type RPAREN expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR COMMA }]
  [expr ::= (*) PLUSPLUS variable , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR COMMA }]
  [expr ::= (*) expr GREATER_EQUAL expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR COMMA }]
  [expr ::= (*) expr MINUS expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR COMMA }]
  [method_cal ::= (*) INPUT LPAREN typeName RPAREN SEMICOLON , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR COMMA }]
  [const_val ::= (*) LONG_CONST , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR COMMA }]
  [expr ::= (*) BITWISE_NOT expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR COMMA }]
  [expr ::= (*) expr OR expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR COMMA }]
  [expr ::= (*) expr BITWISE_XOR expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR COMMA }]
  [const_var_dcl_p ::= IDENTIFIER DIRECT_ASSIGN (*) expr , {SEMICOLON }]
  [const_val ::= (*) STRING_CONST , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR COMMA }]
  [variable ::= (*) IDENTIFIER , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR LBRACKET DOT COMMA PLUSPLUS MINUSMINUS }]
  [expr ::= (*) variable MINUSMINUS , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR COMMA }]
  [expr ::= (*) expr LESS_EQUAL expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR COMMA }]
  [expr ::= (*) expr MULTIPLY expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR COMMA }]
  [method_cal ::= (*) INPUT LPAREN RPAREN SEMICOLON , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR COMMA }]
  [const_val ::= (*) DOUBLE_CONST , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR COMMA }]
  [expr ::= (*) NOT expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR COMMA }]
  [expr ::= (*) LPAREN expr RPAREN , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR COMMA }]
}
transition on CHAR_CONST to state [58]
transition on method_cal to state [57]
transition on const_val to state [56]
transition on LONG_CONST to state [55]
transition on FLOAT_CONST to state [54]
transition on variable to state [53]
transition on MINUS to state [52]
transition on PLUSPLUS to state [51]
transition on BITWISE_NOT to state [50]
transition on INT_CONST to state [49]
transition on LPAREN to state [48]
transition on BOOL_CONST to state [47]
transition on MINUSMINUS to state [46]
transition on IDENTIFIER to state [45]
transition on NOT to state [44]
transition on expr to state [156]
transition on DOUBLE_CONST to state [42]
transition on SIZEOF to state [41]
transition on INPUT to state [6]
transition on STRING_CONST to state [40]

-------------------
lalr_state [156]: {
  [const_var_dcl_p ::= IDENTIFIER DIRECT_ASSIGN expr (*) COMMA const_var_dcl_p , {SEMICOLON }]
  [expr ::= expr (*) DIVIDE expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR COMMA }]
  [expr ::= expr (*) EQUAL expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR COMMA }]
  [expr ::= expr (*) LESS expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR COMMA }]
  [expr ::= expr (*) MINUS expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR COMMA }]
  [expr ::= expr (*) BITWISE_XOR expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR COMMA }]
  [expr ::= expr (*) LESS_EQUAL expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR COMMA }]
  [const_var_dcl_p ::= IDENTIFIER DIRECT_ASSIGN expr (*) , {SEMICOLON }]
  [expr ::= expr (*) MOD expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR COMMA }]
  [expr ::= expr (*) NOT_EQUAL expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR COMMA }]
  [expr ::= expr (*) AND expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR COMMA }]
  [expr ::= expr (*) MULTIPLY expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR COMMA }]
  [expr ::= expr (*) BITWISE_OR expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR COMMA }]
  [expr ::= expr (*) GREATER expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR COMMA }]
  [expr ::= expr (*) PLUS expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR COMMA }]
  [expr ::= expr (*) BITWISE_AND expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR COMMA }]
  [expr ::= expr (*) GREATER_EQUAL expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR COMMA }]
  [expr ::= expr (*) OR expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR COMMA }]
}
transition on OR to state [81]
transition on BITWISE_XOR to state [80]
transition on BITWISE_AND to state [79]
transition on GREATER_EQUAL to state [78]
transition on COMMA to state [157]
transition on LESS to state [76]
transition on NOT_EQUAL to state [77]
transition on LESS_EQUAL to state [75]
transition on BITWISE_OR to state [73]
transition on PLUS to state [72]
transition on EQUAL to state [71]
transition on GREATER to state [70]
transition on MOD to state [69]
transition on MULTIPLY to state [68]
transition on DIVIDE to state [67]
transition on MINUS to state [66]
transition on AND to state [65]

-------------------
lalr_state [157]: {
  [const_var_dcl_p ::= (*) IDENTIFIER DIRECT_ASSIGN expr COMMA const_var_dcl_p , {SEMICOLON }]
  [const_var_dcl_p ::= (*) IDENTIFIER DIRECT_ASSIGN expr , {SEMICOLON }]
  [const_var_dcl_p ::= IDENTIFIER DIRECT_ASSIGN expr COMMA (*) const_var_dcl_p , {SEMICOLON }]
}
transition on const_var_dcl_p to state [158]
transition on IDENTIFIER to state [152]

-------------------
lalr_state [158]: {
  [const_var_dcl_p ::= IDENTIFIER DIRECT_ASSIGN expr COMMA const_var_dcl_p (*) , {SEMICOLON }]
}

-------------------
lalr_state [159]: {
  [var_dcl ::= CONST typeName array_part_no_val (*) NT$0 const_var_dcl_p SEMICOLON , {IDENTIFIER INT LONG FLOAT DOUBLE BOOL CHAR STRING AUTO IF RETURN BREAK CONTINUE SWITCH END FOR REPEAT FOREACH CONST PRINTLN INPUT }]
  [NT$0 ::= (*) , {IDENTIFIER }]
}
transition on NT$0 to state [162]

-------------------
lalr_state [160]: {
  [array_part_no_val ::= (*) , {IDENTIFIER }]
  [array_part_no_val ::= LRBRACKET (*) array_part_no_val , {IDENTIFIER }]
  [array_part_no_val ::= (*) LRBRACKET array_part_no_val , {IDENTIFIER }]
}
transition on LRBRACKET to state [160]
transition on array_part_no_val to state [161]

-------------------
lalr_state [161]: {
  [array_part_no_val ::= LRBRACKET array_part_no_val (*) , {IDENTIFIER }]
}

-------------------
lalr_state [162]: {
  [const_var_dcl_p ::= (*) IDENTIFIER DIRECT_ASSIGN expr COMMA const_var_dcl_p , {SEMICOLON }]
  [var_dcl ::= CONST typeName array_part_no_val NT$0 (*) const_var_dcl_p SEMICOLON , {IDENTIFIER INT LONG FLOAT DOUBLE BOOL CHAR STRING AUTO IF RETURN BREAK CONTINUE SWITCH END FOR REPEAT FOREACH CONST PRINTLN INPUT }]
  [const_var_dcl_p ::= (*) IDENTIFIER DIRECT_ASSIGN expr , {SEMICOLON }]
}
transition on const_var_dcl_p to state [163]
transition on IDENTIFIER to state [152]

-------------------
lalr_state [163]: {
  [var_dcl ::= CONST typeName array_part_no_val NT$0 const_var_dcl_p (*) SEMICOLON , {IDENTIFIER INT LONG FLOAT DOUBLE BOOL CHAR STRING AUTO IF RETURN BREAK CONTINUE SWITCH END FOR REPEAT FOREACH CONST PRINTLN INPUT }]
}
transition on SEMICOLON to state [164]

-------------------
lalr_state [164]: {
  [var_dcl ::= CONST typeName array_part_no_val NT$0 const_var_dcl_p SEMICOLON (*) , {IDENTIFIER INT LONG FLOAT DOUBLE BOOL CHAR STRING AUTO IF RETURN BREAK CONTINUE SWITCH END FOR REPEAT FOREACH CONST PRINTLN INPUT }]
}

-------------------
lalr_state [165]: {
  [statement ::= assignment SEMICOLON (*) , {IDENTIFIER INT LONG FLOAT DOUBLE BOOL CHAR STRING AUTO IF RETURN BREAK CONTINUE SWITCH END FOR REPEAT FOREACH CONST PRINTLN INPUT }]
}

-------------------
lalr_state [166]: {
  [statement ::= BREAK SEMICOLON (*) , {IDENTIFIER INT LONG FLOAT DOUBLE BOOL CHAR STRING AUTO IF RETURN BREAK CONTINUE SWITCH END FOR REPEAT FOREACH CONST PRINTLN INPUT }]
}

-------------------
lalr_state [167]: {
  [const_var_dcl_p ::= (*) IDENTIFIER DIRECT_ASSIGN expr COMMA const_var_dcl_p , {SEMICOLON }]
  [var_dcl ::= AUTO NT$3 (*) const_var_dcl_p SEMICOLON , {IDENTIFIER INT LONG FLOAT DOUBLE BOOL CHAR STRING AUTO IF RETURN BREAK CONTINUE SWITCH END FOR REPEAT FOREACH CONST PRINTLN INPUT }]
  [const_var_dcl_p ::= (*) IDENTIFIER DIRECT_ASSIGN expr , {SEMICOLON }]
}
transition on const_var_dcl_p to state [168]
transition on IDENTIFIER to state [152]

-------------------
lalr_state [168]: {
  [var_dcl ::= AUTO NT$3 const_var_dcl_p (*) SEMICOLON , {IDENTIFIER INT LONG FLOAT DOUBLE BOOL CHAR STRING AUTO IF RETURN BREAK CONTINUE SWITCH END FOR REPEAT FOREACH CONST PRINTLN INPUT }]
}
transition on SEMICOLON to state [169]

-------------------
lalr_state [169]: {
  [var_dcl ::= AUTO NT$3 const_var_dcl_p SEMICOLON (*) , {IDENTIFIER INT LONG FLOAT DOUBLE BOOL CHAR STRING AUTO IF RETURN BREAK CONTINUE SWITCH END FOR REPEAT FOREACH CONST PRINTLN INPUT }]
}

-------------------
lalr_state [170]: {
  [loop_stmt ::= FOREACH LPAREN (*) IDENTIFIER IN variable RPAREN block , {IDENTIFIER INT LONG FLOAT DOUBLE BOOL CHAR STRING AUTO IF RETURN BREAK CONTINUE SWITCH END FOR REPEAT FOREACH CONST PRINTLN INPUT }]
}
transition on IDENTIFIER to state [171]

-------------------
lalr_state [171]: {
  [loop_stmt ::= FOREACH LPAREN IDENTIFIER (*) IN variable RPAREN block , {IDENTIFIER INT LONG FLOAT DOUBLE BOOL CHAR STRING AUTO IF RETURN BREAK CONTINUE SWITCH END FOR REPEAT FOREACH CONST PRINTLN INPUT }]
}
transition on IN to state [172]

-------------------
lalr_state [172]: {
  [variable ::= (*) variable LBRACKET expr RBRACKET , {RPAREN LBRACKET DOT }]
  [variable ::= (*) IDENTIFIER , {RPAREN LBRACKET DOT }]
  [variable ::= (*) variable DOT IDENTIFIER , {RPAREN LBRACKET DOT }]
  [loop_stmt ::= FOREACH LPAREN IDENTIFIER IN (*) variable RPAREN block , {IDENTIFIER INT LONG FLOAT DOUBLE BOOL CHAR STRING AUTO IF RETURN BREAK CONTINUE SWITCH END FOR REPEAT FOREACH CONST PRINTLN INPUT }]
}
transition on IDENTIFIER to state [100]
transition on variable to state [173]

-------------------
lalr_state [173]: {
  [variable ::= variable (*) DOT IDENTIFIER , {RPAREN LBRACKET DOT }]
  [loop_stmt ::= FOREACH LPAREN IDENTIFIER IN variable (*) RPAREN block , {IDENTIFIER INT LONG FLOAT DOUBLE BOOL CHAR STRING AUTO IF RETURN BREAK CONTINUE SWITCH END FOR REPEAT FOREACH CONST PRINTLN INPUT }]
  [variable ::= variable (*) LBRACKET expr RBRACKET , {RPAREN LBRACKET DOT }]
}
transition on DOT to state [62]
transition on LBRACKET to state [60]
transition on RPAREN to state [174]

-------------------
lalr_state [174]: {
  [block ::= (*) BEGIN END , {IDENTIFIER INT LONG FLOAT DOUBLE BOOL CHAR STRING AUTO IF RETURN BREAK CONTINUE SWITCH END FOR REPEAT FOREACH CONST PRINTLN INPUT }]
  [block ::= (*) BEGIN NT$4 block_part NT$5 END , {IDENTIFIER INT LONG FLOAT DOUBLE BOOL CHAR STRING AUTO IF RETURN BREAK CONTINUE SWITCH END FOR REPEAT FOREACH CONST PRINTLN INPUT }]
  [loop_stmt ::= FOREACH LPAREN IDENTIFIER IN variable RPAREN (*) block , {IDENTIFIER INT LONG FLOAT DOUBLE BOOL CHAR STRING AUTO IF RETURN BREAK CONTINUE SWITCH END FOR REPEAT FOREACH CONST PRINTLN INPUT }]
}
transition on block to state [175]
transition on BEGIN to state [2]

-------------------
lalr_state [175]: {
  [loop_stmt ::= FOREACH LPAREN IDENTIFIER IN variable RPAREN block (*) , {IDENTIFIER INT LONG FLOAT DOUBLE BOOL CHAR STRING AUTO IF RETURN BREAK CONTINUE SWITCH END FOR REPEAT FOREACH CONST PRINTLN INPUT }]
}

-------------------
lalr_state [176]: {
  [expr ::= (*) expr BITWISE_OR expr , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [variable ::= (*) variable LBRACKET expr RBRACKET , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN LBRACKET DOT PLUSPLUS MINUSMINUS }]
  [expr ::= (*) variable PLUSPLUS , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [expr ::= (*) expr GREATER expr , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [expr ::= (*) expr DIVIDE expr , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [block_body ::= PRINTLN LPAREN (*) expr RPAREN SEMICOLON , {IDENTIFIER INT LONG FLOAT DOUBLE BOOL CHAR STRING AUTO IF RETURN BREAK CONTINUE SWITCH END FOR REPEAT FOREACH CONST PRINTLN INPUT }]
  [const_val ::= (*) FLOAT_CONST , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [expr ::= (*) const_val , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [expr ::= (*) variable , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [expr ::= (*) expr EQUAL expr , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [variable ::= (*) variable DOT IDENTIFIER , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN LBRACKET DOT PLUSPLUS MINUSMINUS }]
  [expr ::= (*) method_cal , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [expr ::= (*) expr LESS expr , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [expr ::= (*) expr MOD expr , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [block_body ::= PRINTLN LPAREN (*) RPAREN SEMICOLON , {IDENTIFIER INT LONG FLOAT DOUBLE BOOL CHAR STRING AUTO IF RETURN BREAK CONTINUE SWITCH END FOR REPEAT FOREACH CONST PRINTLN INPUT }]
  [const_val ::= (*) CHAR_CONST , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [expr ::= (*) SIZEOF LPAREN typeName RPAREN , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [expr ::= (*) MINUSMINUS variable , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [expr ::= (*) expr NOT_EQUAL expr , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [expr ::= (*) expr PLUS expr , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [method_cal ::= (*) IDENTIFIER LPAREN parameters RPAREN , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [const_val ::= (*) INT_CONST , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [expr ::= (*) MINUS expr , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [expr ::= (*) expr AND expr , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [expr ::= (*) expr BITWISE_AND expr , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [const_val ::= (*) BOOL_CONST , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [expr ::= (*) LPAREN base_type RPAREN expr , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [expr ::= (*) PLUSPLUS variable , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [expr ::= (*) expr GREATER_EQUAL expr , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [expr ::= (*) expr MINUS expr , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [method_cal ::= (*) INPUT LPAREN typeName RPAREN SEMICOLON , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [const_val ::= (*) LONG_CONST , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [expr ::= (*) BITWISE_NOT expr , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [expr ::= (*) expr OR expr , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [expr ::= (*) expr BITWISE_XOR expr , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [const_val ::= (*) STRING_CONST , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [variable ::= (*) IDENTIFIER , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN LBRACKET DOT PLUSPLUS MINUSMINUS }]
  [expr ::= (*) variable MINUSMINUS , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [expr ::= (*) expr LESS_EQUAL expr , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [expr ::= (*) expr MULTIPLY expr , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [method_cal ::= (*) INPUT LPAREN RPAREN SEMICOLON , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [const_val ::= (*) DOUBLE_CONST , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [expr ::= (*) NOT expr , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [expr ::= (*) LPAREN expr RPAREN , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
}
transition on CHAR_CONST to state [58]
transition on method_cal to state [57]
transition on const_val to state [56]
transition on LONG_CONST to state [55]
transition on FLOAT_CONST to state [54]
transition on variable to state [53]
transition on MINUS to state [52]
transition on PLUSPLUS to state [51]
transition on BITWISE_NOT to state [50]
transition on INT_CONST to state [49]
transition on LPAREN to state [48]
transition on BOOL_CONST to state [47]
transition on MINUSMINUS to state [46]
transition on IDENTIFIER to state [45]
transition on NOT to state [44]
transition on RPAREN to state [178]
transition on expr to state [177]
transition on DOUBLE_CONST to state [42]
transition on SIZEOF to state [41]
transition on INPUT to state [6]
transition on STRING_CONST to state [40]

-------------------
lalr_state [177]: {
  [expr ::= expr (*) BITWISE_OR expr , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [expr ::= expr (*) MOD expr , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [expr ::= expr (*) MINUS expr , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [expr ::= expr (*) OR expr , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [expr ::= expr (*) GREATER expr , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [expr ::= expr (*) NOT_EQUAL expr , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [expr ::= expr (*) BITWISE_XOR expr , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [expr ::= expr (*) DIVIDE expr , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [expr ::= expr (*) PLUS expr , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [expr ::= expr (*) AND expr , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [expr ::= expr (*) LESS_EQUAL expr , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [expr ::= expr (*) EQUAL expr , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [expr ::= expr (*) BITWISE_AND expr , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [expr ::= expr (*) MULTIPLY expr , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [block_body ::= PRINTLN LPAREN expr (*) RPAREN SEMICOLON , {IDENTIFIER INT LONG FLOAT DOUBLE BOOL CHAR STRING AUTO IF RETURN BREAK CONTINUE SWITCH END FOR REPEAT FOREACH CONST PRINTLN INPUT }]
  [expr ::= expr (*) LESS expr , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [expr ::= expr (*) GREATER_EQUAL expr , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
}
transition on OR to state [81]
transition on BITWISE_XOR to state [80]
transition on BITWISE_AND to state [79]
transition on GREATER_EQUAL to state [78]
transition on RPAREN to state [180]
transition on NOT_EQUAL to state [77]
transition on LESS to state [76]
transition on LESS_EQUAL to state [75]
transition on BITWISE_OR to state [73]
transition on PLUS to state [72]
transition on EQUAL to state [71]
transition on GREATER to state [70]
transition on MOD to state [69]
transition on MULTIPLY to state [68]
transition on DIVIDE to state [67]
transition on MINUS to state [66]
transition on AND to state [65]

-------------------
lalr_state [178]: {
  [block_body ::= PRINTLN LPAREN RPAREN (*) SEMICOLON , {IDENTIFIER INT LONG FLOAT DOUBLE BOOL CHAR STRING AUTO IF RETURN BREAK CONTINUE SWITCH END FOR REPEAT FOREACH CONST PRINTLN INPUT }]
}
transition on SEMICOLON to state [179]

-------------------
lalr_state [179]: {
  [block_body ::= PRINTLN LPAREN RPAREN SEMICOLON (*) , {IDENTIFIER INT LONG FLOAT DOUBLE BOOL CHAR STRING AUTO IF RETURN BREAK CONTINUE SWITCH END FOR REPEAT FOREACH CONST PRINTLN INPUT }]
}

-------------------
lalr_state [180]: {
  [block_body ::= PRINTLN LPAREN expr RPAREN (*) SEMICOLON , {IDENTIFIER INT LONG FLOAT DOUBLE BOOL CHAR STRING AUTO IF RETURN BREAK CONTINUE SWITCH END FOR REPEAT FOREACH CONST PRINTLN INPUT }]
}
transition on SEMICOLON to state [181]

-------------------
lalr_state [181]: {
  [block_body ::= PRINTLN LPAREN expr RPAREN SEMICOLON (*) , {IDENTIFIER INT LONG FLOAT DOUBLE BOOL CHAR STRING AUTO IF RETURN BREAK CONTINUE SWITCH END FOR REPEAT FOREACH CONST PRINTLN INPUT }]
}

-------------------
lalr_state [182]: {
  [block ::= BEGIN NT$4 block_part NT$5 (*) END , {EOF IDENTIFIER INT LONG FLOAT DOUBLE BOOL CHAR STRING AUTO IF ELSE RETURN BREAK CONTINUE SWITCH CASE DEFAULT END FOR REPEAT UNTIL FOREACH CONST PRINTLN INPUT }]
}
transition on END to state [183]

-------------------
lalr_state [183]: {
  [block ::= BEGIN NT$4 block_part NT$5 END (*) , {EOF IDENTIFIER INT LONG FLOAT DOUBLE BOOL CHAR STRING AUTO IF ELSE RETURN BREAK CONTINUE SWITCH CASE DEFAULT END FOR REPEAT UNTIL FOREACH CONST PRINTLN INPUT }]
}

-------------------
lalr_state [184]: {
  [NT$1 ::= (*) , {IDENTIFIER }]
  [var_dcl ::= typeName array_part_no_val (*) NT$1 var_dcl_p SEMICOLON , {IDENTIFIER INT LONG FLOAT DOUBLE BOOL CHAR STRING AUTO IF RETURN BREAK CONTINUE SWITCH END FOR REPEAT FOREACH CONST PRINTLN INPUT }]
}
transition on NT$1 to state [185]

-------------------
lalr_state [185]: {
  [var_dcl_p ::= (*) IDENTIFIER DIRECT_ASSIGN expr , {SEMICOLON }]
  [var_dcl_p ::= (*) IDENTIFIER COMMA var_dcl_p , {SEMICOLON }]
  [var_dcl_p ::= (*) IDENTIFIER DIRECT_ASSIGN expr COMMA var_dcl_p , {SEMICOLON }]
  [var_dcl ::= typeName array_part_no_val NT$1 (*) var_dcl_p SEMICOLON , {IDENTIFIER INT LONG FLOAT DOUBLE BOOL CHAR STRING AUTO IF RETURN BREAK CONTINUE SWITCH END FOR REPEAT FOREACH CONST PRINTLN INPUT }]
  [var_dcl_p ::= (*) IDENTIFIER , {SEMICOLON }]
}
transition on IDENTIFIER to state [187]
transition on var_dcl_p to state [186]

-------------------
lalr_state [186]: {
  [var_dcl ::= typeName array_part_no_val NT$1 var_dcl_p (*) SEMICOLON , {IDENTIFIER INT LONG FLOAT DOUBLE BOOL CHAR STRING AUTO IF RETURN BREAK CONTINUE SWITCH END FOR REPEAT FOREACH CONST PRINTLN INPUT }]
}
transition on SEMICOLON to state [194]

-------------------
lalr_state [187]: {
  [var_dcl_p ::= IDENTIFIER (*) DIRECT_ASSIGN expr , {SEMICOLON }]
  [var_dcl_p ::= IDENTIFIER (*) COMMA var_dcl_p , {SEMICOLON }]
  [var_dcl_p ::= IDENTIFIER (*) DIRECT_ASSIGN expr COMMA var_dcl_p , {SEMICOLON }]
  [var_dcl_p ::= IDENTIFIER (*) , {SEMICOLON }]
}
transition on DIRECT_ASSIGN to state [189]
transition on COMMA to state [188]

-------------------
lalr_state [188]: {
  [var_dcl_p ::= IDENTIFIER COMMA (*) var_dcl_p , {SEMICOLON }]
  [var_dcl_p ::= (*) IDENTIFIER DIRECT_ASSIGN expr , {SEMICOLON }]
  [var_dcl_p ::= (*) IDENTIFIER COMMA var_dcl_p , {SEMICOLON }]
  [var_dcl_p ::= (*) IDENTIFIER DIRECT_ASSIGN expr COMMA var_dcl_p , {SEMICOLON }]
  [var_dcl_p ::= (*) IDENTIFIER , {SEMICOLON }]
}
transition on IDENTIFIER to state [187]
transition on var_dcl_p to state [193]

-------------------
lalr_state [189]: {
  [expr ::= (*) expr BITWISE_OR expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR COMMA }]
  [variable ::= (*) variable LBRACKET expr RBRACKET , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR LBRACKET DOT COMMA PLUSPLUS MINUSMINUS }]
  [expr ::= (*) variable PLUSPLUS , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR COMMA }]
  [expr ::= (*) expr GREATER expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR COMMA }]
  [expr ::= (*) expr DIVIDE expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR COMMA }]
  [const_val ::= (*) FLOAT_CONST , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR COMMA }]
  [expr ::= (*) const_val , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR COMMA }]
  [expr ::= (*) variable , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR COMMA }]
  [expr ::= (*) expr EQUAL expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR COMMA }]
  [variable ::= (*) variable DOT IDENTIFIER , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR LBRACKET DOT COMMA PLUSPLUS MINUSMINUS }]
  [expr ::= (*) method_cal , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR COMMA }]
  [expr ::= (*) expr LESS expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR COMMA }]
  [expr ::= (*) expr MOD expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR COMMA }]
  [const_val ::= (*) CHAR_CONST , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR COMMA }]
  [expr ::= (*) SIZEOF LPAREN typeName RPAREN , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR COMMA }]
  [expr ::= (*) MINUSMINUS variable , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR COMMA }]
  [expr ::= (*) expr NOT_EQUAL expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR COMMA }]
  [expr ::= (*) expr PLUS expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR COMMA }]
  [method_cal ::= (*) IDENTIFIER LPAREN parameters RPAREN , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR COMMA }]
  [var_dcl_p ::= IDENTIFIER DIRECT_ASSIGN (*) expr COMMA var_dcl_p , {SEMICOLON }]
  [const_val ::= (*) INT_CONST , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR COMMA }]
  [expr ::= (*) MINUS expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR COMMA }]
  [expr ::= (*) expr AND expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR COMMA }]
  [expr ::= (*) expr BITWISE_AND expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR COMMA }]
  [const_val ::= (*) BOOL_CONST , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR COMMA }]
  [expr ::= (*) LPAREN base_type RPAREN expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR COMMA }]
  [expr ::= (*) PLUSPLUS variable , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR COMMA }]
  [expr ::= (*) expr GREATER_EQUAL expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR COMMA }]
  [expr ::= (*) expr MINUS expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR COMMA }]
  [method_cal ::= (*) INPUT LPAREN typeName RPAREN SEMICOLON , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR COMMA }]
  [var_dcl_p ::= IDENTIFIER DIRECT_ASSIGN (*) expr , {SEMICOLON }]
  [const_val ::= (*) LONG_CONST , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR COMMA }]
  [expr ::= (*) BITWISE_NOT expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR COMMA }]
  [expr ::= (*) expr OR expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR COMMA }]
  [expr ::= (*) expr BITWISE_XOR expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR COMMA }]
  [const_val ::= (*) STRING_CONST , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR COMMA }]
  [variable ::= (*) IDENTIFIER , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR LBRACKET DOT COMMA PLUSPLUS MINUSMINUS }]
  [expr ::= (*) variable MINUSMINUS , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR COMMA }]
  [expr ::= (*) expr LESS_EQUAL expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR COMMA }]
  [expr ::= (*) expr MULTIPLY expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR COMMA }]
  [method_cal ::= (*) INPUT LPAREN RPAREN SEMICOLON , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR COMMA }]
  [const_val ::= (*) DOUBLE_CONST , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR COMMA }]
  [expr ::= (*) NOT expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR COMMA }]
  [expr ::= (*) LPAREN expr RPAREN , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR COMMA }]
}
transition on CHAR_CONST to state [58]
transition on method_cal to state [57]
transition on const_val to state [56]
transition on LONG_CONST to state [55]
transition on FLOAT_CONST to state [54]
transition on variable to state [53]
transition on MINUS to state [52]
transition on PLUSPLUS to state [51]
transition on BITWISE_NOT to state [50]
transition on INT_CONST to state [49]
transition on LPAREN to state [48]
transition on BOOL_CONST to state [47]
transition on MINUSMINUS to state [46]
transition on IDENTIFIER to state [45]
transition on NOT to state [44]
transition on expr to state [190]
transition on DOUBLE_CONST to state [42]
transition on SIZEOF to state [41]
transition on INPUT to state [6]
transition on STRING_CONST to state [40]

-------------------
lalr_state [190]: {
  [var_dcl_p ::= IDENTIFIER DIRECT_ASSIGN expr (*) , {SEMICOLON }]
  [expr ::= expr (*) DIVIDE expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR COMMA }]
  [expr ::= expr (*) EQUAL expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR COMMA }]
  [expr ::= expr (*) LESS expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR COMMA }]
  [expr ::= expr (*) MINUS expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR COMMA }]
  [expr ::= expr (*) BITWISE_XOR expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR COMMA }]
  [expr ::= expr (*) LESS_EQUAL expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR COMMA }]
  [expr ::= expr (*) MOD expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR COMMA }]
  [expr ::= expr (*) NOT_EQUAL expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR COMMA }]
  [expr ::= expr (*) AND expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR COMMA }]
  [var_dcl_p ::= IDENTIFIER DIRECT_ASSIGN expr (*) COMMA var_dcl_p , {SEMICOLON }]
  [expr ::= expr (*) MULTIPLY expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR COMMA }]
  [expr ::= expr (*) BITWISE_OR expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR COMMA }]
  [expr ::= expr (*) GREATER expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR COMMA }]
  [expr ::= expr (*) PLUS expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR COMMA }]
  [expr ::= expr (*) BITWISE_AND expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR COMMA }]
  [expr ::= expr (*) GREATER_EQUAL expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR COMMA }]
  [expr ::= expr (*) OR expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR COMMA }]
}
transition on OR to state [81]
transition on BITWISE_XOR to state [80]
transition on BITWISE_AND to state [79]
transition on GREATER_EQUAL to state [78]
transition on NOT_EQUAL to state [77]
transition on LESS to state [76]
transition on COMMA to state [191]
transition on LESS_EQUAL to state [75]
transition on BITWISE_OR to state [73]
transition on PLUS to state [72]
transition on EQUAL to state [71]
transition on GREATER to state [70]
transition on MOD to state [69]
transition on MULTIPLY to state [68]
transition on DIVIDE to state [67]
transition on MINUS to state [66]
transition on AND to state [65]

-------------------
lalr_state [191]: {
  [var_dcl_p ::= (*) IDENTIFIER DIRECT_ASSIGN expr , {SEMICOLON }]
  [var_dcl_p ::= IDENTIFIER DIRECT_ASSIGN expr COMMA (*) var_dcl_p , {SEMICOLON }]
  [var_dcl_p ::= (*) IDENTIFIER COMMA var_dcl_p , {SEMICOLON }]
  [var_dcl_p ::= (*) IDENTIFIER DIRECT_ASSIGN expr COMMA var_dcl_p , {SEMICOLON }]
  [var_dcl_p ::= (*) IDENTIFIER , {SEMICOLON }]
}
transition on IDENTIFIER to state [187]
transition on var_dcl_p to state [192]

-------------------
lalr_state [192]: {
  [var_dcl_p ::= IDENTIFIER DIRECT_ASSIGN expr COMMA var_dcl_p (*) , {SEMICOLON }]
}

-------------------
lalr_state [193]: {
  [var_dcl_p ::= IDENTIFIER COMMA var_dcl_p (*) , {SEMICOLON }]
}

-------------------
lalr_state [194]: {
  [var_dcl ::= typeName array_part_no_val NT$1 var_dcl_p SEMICOLON (*) , {IDENTIFIER INT LONG FLOAT DOUBLE BOOL CHAR STRING AUTO IF RETURN BREAK CONTINUE SWITCH END FOR REPEAT FOREACH CONST PRINTLN INPUT }]
}

-------------------
lalr_state [195]: {
  [expr ::= (*) expr BITWISE_OR expr , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [variable ::= (*) variable LBRACKET expr RBRACKET , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN LBRACKET DOT PLUSPLUS MINUSMINUS }]
  [expr ::= (*) variable PLUSPLUS , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [expr ::= (*) expr GREATER expr , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [expr ::= (*) expr DIVIDE expr , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [const_val ::= (*) FLOAT_CONST , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [expr ::= (*) const_val , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [expr ::= (*) variable , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [expr ::= (*) expr EQUAL expr , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [variable ::= (*) variable DOT IDENTIFIER , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN LBRACKET DOT PLUSPLUS MINUSMINUS }]
  [expr ::= (*) method_cal , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [expr ::= (*) expr LESS expr , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [expr ::= (*) expr MOD expr , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [const_val ::= (*) CHAR_CONST , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [expr ::= (*) SIZEOF LPAREN typeName RPAREN , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [expr ::= (*) MINUSMINUS variable , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [expr ::= (*) expr NOT_EQUAL expr , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [expr ::= (*) expr PLUS expr , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [method_cal ::= (*) IDENTIFIER LPAREN parameters RPAREN , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [const_val ::= (*) INT_CONST , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [expr ::= (*) MINUS expr , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [expr ::= (*) expr AND expr , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [expr ::= (*) expr BITWISE_AND expr , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [cond_stmt ::= IF LPAREN (*) expr RPAREN block ELSE block , {IDENTIFIER INT LONG FLOAT DOUBLE BOOL CHAR STRING AUTO IF RETURN BREAK CONTINUE SWITCH END FOR REPEAT FOREACH CONST PRINTLN INPUT }]
  [const_val ::= (*) BOOL_CONST , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [expr ::= (*) LPAREN base_type RPAREN expr , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [expr ::= (*) PLUSPLUS variable , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [expr ::= (*) expr GREATER_EQUAL expr , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [expr ::= (*) expr MINUS expr , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [method_cal ::= (*) INPUT LPAREN typeName RPAREN SEMICOLON , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [const_val ::= (*) LONG_CONST , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [expr ::= (*) BITWISE_NOT expr , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [expr ::= (*) expr OR expr , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [expr ::= (*) expr BITWISE_XOR expr , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [cond_stmt ::= IF LPAREN (*) expr RPAREN block , {IDENTIFIER INT LONG FLOAT DOUBLE BOOL CHAR STRING AUTO IF RETURN BREAK CONTINUE SWITCH END FOR REPEAT FOREACH CONST PRINTLN INPUT }]
  [const_val ::= (*) STRING_CONST , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [variable ::= (*) IDENTIFIER , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN LBRACKET DOT PLUSPLUS MINUSMINUS }]
  [expr ::= (*) variable MINUSMINUS , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [expr ::= (*) expr LESS_EQUAL expr , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [expr ::= (*) expr MULTIPLY expr , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [method_cal ::= (*) INPUT LPAREN RPAREN SEMICOLON , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [const_val ::= (*) DOUBLE_CONST , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [expr ::= (*) NOT expr , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [expr ::= (*) LPAREN expr RPAREN , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
}
transition on CHAR_CONST to state [58]
transition on method_cal to state [57]
transition on const_val to state [56]
transition on LONG_CONST to state [55]
transition on FLOAT_CONST to state [54]
transition on variable to state [53]
transition on MINUS to state [52]
transition on PLUSPLUS to state [51]
transition on BITWISE_NOT to state [50]
transition on INT_CONST to state [49]
transition on LPAREN to state [48]
transition on BOOL_CONST to state [47]
transition on MINUSMINUS to state [46]
transition on IDENTIFIER to state [45]
transition on NOT to state [44]
transition on expr to state [196]
transition on DOUBLE_CONST to state [42]
transition on SIZEOF to state [41]
transition on INPUT to state [6]
transition on STRING_CONST to state [40]

-------------------
lalr_state [196]: {
  [cond_stmt ::= IF LPAREN expr (*) RPAREN block , {IDENTIFIER INT LONG FLOAT DOUBLE BOOL CHAR STRING AUTO IF RETURN BREAK CONTINUE SWITCH END FOR REPEAT FOREACH CONST PRINTLN INPUT }]
  [expr ::= expr (*) DIVIDE expr , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [expr ::= expr (*) EQUAL expr , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [expr ::= expr (*) LESS expr , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [expr ::= expr (*) MINUS expr , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [expr ::= expr (*) BITWISE_XOR expr , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [expr ::= expr (*) LESS_EQUAL expr , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [expr ::= expr (*) MOD expr , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [expr ::= expr (*) NOT_EQUAL expr , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [expr ::= expr (*) AND expr , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [cond_stmt ::= IF LPAREN expr (*) RPAREN block ELSE block , {IDENTIFIER INT LONG FLOAT DOUBLE BOOL CHAR STRING AUTO IF RETURN BREAK CONTINUE SWITCH END FOR REPEAT FOREACH CONST PRINTLN INPUT }]
  [expr ::= expr (*) MULTIPLY expr , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [expr ::= expr (*) BITWISE_OR expr , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [expr ::= expr (*) GREATER expr , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [expr ::= expr (*) PLUS expr , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [expr ::= expr (*) BITWISE_AND expr , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [expr ::= expr (*) GREATER_EQUAL expr , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [expr ::= expr (*) OR expr , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
}
transition on OR to state [81]
transition on BITWISE_XOR to state [80]
transition on BITWISE_AND to state [79]
transition on GREATER_EQUAL to state [78]
transition on RPAREN to state [197]
transition on LESS to state [76]
transition on NOT_EQUAL to state [77]
transition on LESS_EQUAL to state [75]
transition on BITWISE_OR to state [73]
transition on PLUS to state [72]
transition on EQUAL to state [71]
transition on GREATER to state [70]
transition on MOD to state [69]
transition on MULTIPLY to state [68]
transition on DIVIDE to state [67]
transition on MINUS to state [66]
transition on AND to state [65]

-------------------
lalr_state [197]: {
  [cond_stmt ::= IF LPAREN expr RPAREN (*) block , {IDENTIFIER INT LONG FLOAT DOUBLE BOOL CHAR STRING AUTO IF RETURN BREAK CONTINUE SWITCH END FOR REPEAT FOREACH CONST PRINTLN INPUT }]
  [block ::= (*) BEGIN END , {IDENTIFIER INT LONG FLOAT DOUBLE BOOL CHAR STRING AUTO IF ELSE RETURN BREAK CONTINUE SWITCH END FOR REPEAT FOREACH CONST PRINTLN INPUT }]
  [cond_stmt ::= IF LPAREN expr RPAREN (*) block ELSE block , {IDENTIFIER INT LONG FLOAT DOUBLE BOOL CHAR STRING AUTO IF RETURN BREAK CONTINUE SWITCH END FOR REPEAT FOREACH CONST PRINTLN INPUT }]
  [block ::= (*) BEGIN NT$4 block_part NT$5 END , {IDENTIFIER INT LONG FLOAT DOUBLE BOOL CHAR STRING AUTO IF ELSE RETURN BREAK CONTINUE SWITCH END FOR REPEAT FOREACH CONST PRINTLN INPUT }]
}
transition on block to state [198]
transition on BEGIN to state [2]

-------------------
lalr_state [198]: {
  [cond_stmt ::= IF LPAREN expr RPAREN block (*) , {IDENTIFIER INT LONG FLOAT DOUBLE BOOL CHAR STRING AUTO IF RETURN BREAK CONTINUE SWITCH END FOR REPEAT FOREACH CONST PRINTLN INPUT }]
  [cond_stmt ::= IF LPAREN expr RPAREN block (*) ELSE block , {IDENTIFIER INT LONG FLOAT DOUBLE BOOL CHAR STRING AUTO IF RETURN BREAK CONTINUE SWITCH END FOR REPEAT FOREACH CONST PRINTLN INPUT }]
}
transition on ELSE to state [199]

-------------------
lalr_state [199]: {
  [block ::= (*) BEGIN END , {IDENTIFIER INT LONG FLOAT DOUBLE BOOL CHAR STRING AUTO IF RETURN BREAK CONTINUE SWITCH END FOR REPEAT FOREACH CONST PRINTLN INPUT }]
  [cond_stmt ::= IF LPAREN expr RPAREN block ELSE (*) block , {IDENTIFIER INT LONG FLOAT DOUBLE BOOL CHAR STRING AUTO IF RETURN BREAK CONTINUE SWITCH END FOR REPEAT FOREACH CONST PRINTLN INPUT }]
  [block ::= (*) BEGIN NT$4 block_part NT$5 END , {IDENTIFIER INT LONG FLOAT DOUBLE BOOL CHAR STRING AUTO IF RETURN BREAK CONTINUE SWITCH END FOR REPEAT FOREACH CONST PRINTLN INPUT }]
}
transition on block to state [200]
transition on BEGIN to state [2]

-------------------
lalr_state [200]: {
  [cond_stmt ::= IF LPAREN expr RPAREN block ELSE block (*) , {IDENTIFIER INT LONG FLOAT DOUBLE BOOL CHAR STRING AUTO IF RETURN BREAK CONTINUE SWITCH END FOR REPEAT FOREACH CONST PRINTLN INPUT }]
}

-------------------
lalr_state [201]: {
  [expr ::= (*) expr BITWISE_OR expr , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [cond_stmt ::= SWITCH LPAREN (*) expr RPAREN OF COLON BEGIN case_part DEFAULT COLON block END , {IDENTIFIER INT LONG FLOAT DOUBLE BOOL CHAR STRING AUTO IF RETURN BREAK CONTINUE SWITCH END FOR REPEAT FOREACH CONST PRINTLN INPUT }]
  [variable ::= (*) variable LBRACKET expr RBRACKET , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN LBRACKET DOT PLUSPLUS MINUSMINUS }]
  [expr ::= (*) variable PLUSPLUS , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [expr ::= (*) expr GREATER expr , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [expr ::= (*) expr DIVIDE expr , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [const_val ::= (*) FLOAT_CONST , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [expr ::= (*) const_val , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [expr ::= (*) variable , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [cond_stmt ::= SWITCH LPAREN (*) expr RPAREN OF COLON BEGIN case_part END , {IDENTIFIER INT LONG FLOAT DOUBLE BOOL CHAR STRING AUTO IF RETURN BREAK CONTINUE SWITCH END FOR REPEAT FOREACH CONST PRINTLN INPUT }]
  [expr ::= (*) expr EQUAL expr , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [variable ::= (*) variable DOT IDENTIFIER , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN LBRACKET DOT PLUSPLUS MINUSMINUS }]
  [expr ::= (*) method_cal , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [expr ::= (*) expr LESS expr , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [expr ::= (*) expr MOD expr , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [const_val ::= (*) CHAR_CONST , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [expr ::= (*) SIZEOF LPAREN typeName RPAREN , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [expr ::= (*) MINUSMINUS variable , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [expr ::= (*) expr NOT_EQUAL expr , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [expr ::= (*) expr PLUS expr , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [method_cal ::= (*) IDENTIFIER LPAREN parameters RPAREN , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [const_val ::= (*) INT_CONST , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [expr ::= (*) MINUS expr , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [expr ::= (*) expr AND expr , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [expr ::= (*) expr BITWISE_AND expr , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [const_val ::= (*) BOOL_CONST , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [expr ::= (*) LPAREN base_type RPAREN expr , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [expr ::= (*) PLUSPLUS variable , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [expr ::= (*) expr GREATER_EQUAL expr , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [expr ::= (*) expr MINUS expr , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [method_cal ::= (*) INPUT LPAREN typeName RPAREN SEMICOLON , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [const_val ::= (*) LONG_CONST , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [expr ::= (*) BITWISE_NOT expr , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [expr ::= (*) expr OR expr , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [expr ::= (*) expr BITWISE_XOR expr , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [const_val ::= (*) STRING_CONST , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [variable ::= (*) IDENTIFIER , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN LBRACKET DOT PLUSPLUS MINUSMINUS }]
  [expr ::= (*) variable MINUSMINUS , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [expr ::= (*) expr LESS_EQUAL expr , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [expr ::= (*) expr MULTIPLY expr , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [method_cal ::= (*) INPUT LPAREN RPAREN SEMICOLON , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [const_val ::= (*) DOUBLE_CONST , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [expr ::= (*) NOT expr , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [expr ::= (*) LPAREN expr RPAREN , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
}
transition on CHAR_CONST to state [58]
transition on method_cal to state [57]
transition on const_val to state [56]
transition on LONG_CONST to state [55]
transition on FLOAT_CONST to state [54]
transition on variable to state [53]
transition on MINUS to state [52]
transition on PLUSPLUS to state [51]
transition on BITWISE_NOT to state [50]
transition on INT_CONST to state [49]
transition on LPAREN to state [48]
transition on BOOL_CONST to state [47]
transition on MINUSMINUS to state [46]
transition on IDENTIFIER to state [45]
transition on NOT to state [44]
transition on expr to state [202]
transition on DOUBLE_CONST to state [42]
transition on SIZEOF to state [41]
transition on INPUT to state [6]
transition on STRING_CONST to state [40]

-------------------
lalr_state [202]: {
  [expr ::= expr (*) DIVIDE expr , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [expr ::= expr (*) EQUAL expr , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [expr ::= expr (*) LESS expr , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [expr ::= expr (*) MINUS expr , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [expr ::= expr (*) BITWISE_XOR expr , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [expr ::= expr (*) LESS_EQUAL expr , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [cond_stmt ::= SWITCH LPAREN expr (*) RPAREN OF COLON BEGIN case_part DEFAULT COLON block END , {IDENTIFIER INT LONG FLOAT DOUBLE BOOL CHAR STRING AUTO IF RETURN BREAK CONTINUE SWITCH END FOR REPEAT FOREACH CONST PRINTLN INPUT }]
  [expr ::= expr (*) MOD expr , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [expr ::= expr (*) NOT_EQUAL expr , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [expr ::= expr (*) AND expr , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [expr ::= expr (*) MULTIPLY expr , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [expr ::= expr (*) BITWISE_OR expr , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [expr ::= expr (*) GREATER expr , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [cond_stmt ::= SWITCH LPAREN expr (*) RPAREN OF COLON BEGIN case_part END , {IDENTIFIER INT LONG FLOAT DOUBLE BOOL CHAR STRING AUTO IF RETURN BREAK CONTINUE SWITCH END FOR REPEAT FOREACH CONST PRINTLN INPUT }]
  [expr ::= expr (*) PLUS expr , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [expr ::= expr (*) BITWISE_AND expr , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [expr ::= expr (*) GREATER_EQUAL expr , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
  [expr ::= expr (*) OR expr , {PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN }]
}
transition on OR to state [81]
transition on BITWISE_XOR to state [80]
transition on BITWISE_AND to state [79]
transition on GREATER_EQUAL to state [78]
transition on RPAREN to state [203]
transition on LESS to state [76]
transition on NOT_EQUAL to state [77]
transition on LESS_EQUAL to state [75]
transition on BITWISE_OR to state [73]
transition on PLUS to state [72]
transition on EQUAL to state [71]
transition on GREATER to state [70]
transition on MOD to state [69]
transition on MULTIPLY to state [68]
transition on DIVIDE to state [67]
transition on MINUS to state [66]
transition on AND to state [65]

-------------------
lalr_state [203]: {
  [cond_stmt ::= SWITCH LPAREN expr RPAREN (*) OF COLON BEGIN case_part END , {IDENTIFIER INT LONG FLOAT DOUBLE BOOL CHAR STRING AUTO IF RETURN BREAK CONTINUE SWITCH END FOR REPEAT FOREACH CONST PRINTLN INPUT }]
  [cond_stmt ::= SWITCH LPAREN expr RPAREN (*) OF COLON BEGIN case_part DEFAULT COLON block END , {IDENTIFIER INT LONG FLOAT DOUBLE BOOL CHAR STRING AUTO IF RETURN BREAK CONTINUE SWITCH END FOR REPEAT FOREACH CONST PRINTLN INPUT }]
}
transition on OF to state [204]

-------------------
lalr_state [204]: {
  [cond_stmt ::= SWITCH LPAREN expr RPAREN OF (*) COLON BEGIN case_part END , {IDENTIFIER INT LONG FLOAT DOUBLE BOOL CHAR STRING AUTO IF RETURN BREAK CONTINUE SWITCH END FOR REPEAT FOREACH CONST PRINTLN INPUT }]
  [cond_stmt ::= SWITCH LPAREN expr RPAREN OF (*) COLON BEGIN case_part DEFAULT COLON block END , {IDENTIFIER INT LONG FLOAT DOUBLE BOOL CHAR STRING AUTO IF RETURN BREAK CONTINUE SWITCH END FOR REPEAT FOREACH CONST PRINTLN INPUT }]
}
transition on COLON to state [205]

-------------------
lalr_state [205]: {
  [cond_stmt ::= SWITCH LPAREN expr RPAREN OF COLON (*) BEGIN case_part END , {IDENTIFIER INT LONG FLOAT DOUBLE BOOL CHAR STRING AUTO IF RETURN BREAK CONTINUE SWITCH END FOR REPEAT FOREACH CONST PRINTLN INPUT }]
  [cond_stmt ::= SWITCH LPAREN expr RPAREN OF COLON (*) BEGIN case_part DEFAULT COLON block END , {IDENTIFIER INT LONG FLOAT DOUBLE BOOL CHAR STRING AUTO IF RETURN BREAK CONTINUE SWITCH END FOR REPEAT FOREACH CONST PRINTLN INPUT }]
}
transition on BEGIN to state [206]

-------------------
lalr_state [206]: {
  [case_part ::= (*) CASE INT_CONST COLON block case_part , {DEFAULT END }]
  [cond_stmt ::= SWITCH LPAREN expr RPAREN OF COLON BEGIN (*) case_part END , {IDENTIFIER INT LONG FLOAT DOUBLE BOOL CHAR STRING AUTO IF RETURN BREAK CONTINUE SWITCH END FOR REPEAT FOREACH CONST PRINTLN INPUT }]
  [case_part ::= (*) , {DEFAULT END }]
  [cond_stmt ::= SWITCH LPAREN expr RPAREN OF COLON BEGIN (*) case_part DEFAULT COLON block END , {IDENTIFIER INT LONG FLOAT DOUBLE BOOL CHAR STRING AUTO IF RETURN BREAK CONTINUE SWITCH END FOR REPEAT FOREACH CONST PRINTLN INPUT }]
}
transition on CASE to state [208]
transition on case_part to state [207]

-------------------
lalr_state [207]: {
  [cond_stmt ::= SWITCH LPAREN expr RPAREN OF COLON BEGIN case_part (*) END , {IDENTIFIER INT LONG FLOAT DOUBLE BOOL CHAR STRING AUTO IF RETURN BREAK CONTINUE SWITCH END FOR REPEAT FOREACH CONST PRINTLN INPUT }]
  [cond_stmt ::= SWITCH LPAREN expr RPAREN OF COLON BEGIN case_part (*) DEFAULT COLON block END , {IDENTIFIER INT LONG FLOAT DOUBLE BOOL CHAR STRING AUTO IF RETURN BREAK CONTINUE SWITCH END FOR REPEAT FOREACH CONST PRINTLN INPUT }]
}
transition on END to state [214]
transition on DEFAULT to state [213]

-------------------
lalr_state [208]: {
  [case_part ::= CASE (*) INT_CONST COLON block case_part , {DEFAULT END }]
}
transition on INT_CONST to state [209]

-------------------
lalr_state [209]: {
  [case_part ::= CASE INT_CONST (*) COLON block case_part , {DEFAULT END }]
}
transition on COLON to state [210]

-------------------
lalr_state [210]: {
  [block ::= (*) BEGIN END , {CASE DEFAULT END }]
  [block ::= (*) BEGIN NT$4 block_part NT$5 END , {CASE DEFAULT END }]
  [case_part ::= CASE INT_CONST COLON (*) block case_part , {DEFAULT END }]
}
transition on block to state [211]
transition on BEGIN to state [2]

-------------------
lalr_state [211]: {
  [case_part ::= (*) CASE INT_CONST COLON block case_part , {DEFAULT END }]
  [case_part ::= (*) , {DEFAULT END }]
  [case_part ::= CASE INT_CONST COLON block (*) case_part , {DEFAULT END }]
}
transition on CASE to state [208]
transition on case_part to state [212]

-------------------
lalr_state [212]: {
  [case_part ::= CASE INT_CONST COLON block case_part (*) , {DEFAULT END }]
}

-------------------
lalr_state [213]: {
  [cond_stmt ::= SWITCH LPAREN expr RPAREN OF COLON BEGIN case_part DEFAULT (*) COLON block END , {IDENTIFIER INT LONG FLOAT DOUBLE BOOL CHAR STRING AUTO IF RETURN BREAK CONTINUE SWITCH END FOR REPEAT FOREACH CONST PRINTLN INPUT }]
}
transition on COLON to state [215]

-------------------
lalr_state [214]: {
  [cond_stmt ::= SWITCH LPAREN expr RPAREN OF COLON BEGIN case_part END (*) , {IDENTIFIER INT LONG FLOAT DOUBLE BOOL CHAR STRING AUTO IF RETURN BREAK CONTINUE SWITCH END FOR REPEAT FOREACH CONST PRINTLN INPUT }]
}

-------------------
lalr_state [215]: {
  [cond_stmt ::= SWITCH LPAREN expr RPAREN OF COLON BEGIN case_part DEFAULT COLON (*) block END , {IDENTIFIER INT LONG FLOAT DOUBLE BOOL CHAR STRING AUTO IF RETURN BREAK CONTINUE SWITCH END FOR REPEAT FOREACH CONST PRINTLN INPUT }]
  [block ::= (*) BEGIN END , {END }]
  [block ::= (*) BEGIN NT$4 block_part NT$5 END , {END }]
}
transition on block to state [216]
transition on BEGIN to state [2]

-------------------
lalr_state [216]: {
  [cond_stmt ::= SWITCH LPAREN expr RPAREN OF COLON BEGIN case_part DEFAULT COLON block (*) END , {IDENTIFIER INT LONG FLOAT DOUBLE BOOL CHAR STRING AUTO IF RETURN BREAK CONTINUE SWITCH END FOR REPEAT FOREACH CONST PRINTLN INPUT }]
}
transition on END to state [217]

-------------------
lalr_state [217]: {
  [cond_stmt ::= SWITCH LPAREN expr RPAREN OF COLON BEGIN case_part DEFAULT COLON block END (*) , {IDENTIFIER INT LONG FLOAT DOUBLE BOOL CHAR STRING AUTO IF RETURN BREAK CONTINUE SWITCH END FOR REPEAT FOREACH CONST PRINTLN INPUT }]
}

-------------------
lalr_state [218]: {
  [block_part ::= block_body block_part (*) , {END }]
}

-------------------
lalr_state [219]: {
  [statement ::= RETURN SEMICOLON (*) , {IDENTIFIER INT LONG FLOAT DOUBLE BOOL CHAR STRING AUTO IF RETURN BREAK CONTINUE SWITCH END FOR REPEAT FOREACH CONST PRINTLN INPUT }]
}

-------------------
lalr_state [220]: {
  [expr ::= expr (*) BITWISE_OR expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR }]
  [expr ::= expr (*) MOD expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR }]
  [expr ::= expr (*) MINUS expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR }]
  [expr ::= expr (*) OR expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR }]
  [expr ::= expr (*) GREATER expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR }]
  [expr ::= expr (*) NOT_EQUAL expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR }]
  [expr ::= expr (*) BITWISE_XOR expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR }]
  [expr ::= expr (*) DIVIDE expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR }]
  [expr ::= expr (*) PLUS expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR }]
  [expr ::= expr (*) AND expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR }]
  [expr ::= expr (*) LESS_EQUAL expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR }]
  [expr ::= expr (*) EQUAL expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR }]
  [expr ::= expr (*) BITWISE_AND expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR }]
  [expr ::= expr (*) MULTIPLY expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR }]
  [statement ::= RETURN expr (*) SEMICOLON , {IDENTIFIER INT LONG FLOAT DOUBLE BOOL CHAR STRING AUTO IF RETURN BREAK CONTINUE SWITCH END FOR REPEAT FOREACH CONST PRINTLN INPUT }]
  [expr ::= expr (*) LESS expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR }]
  [expr ::= expr (*) GREATER_EQUAL expr , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR }]
}
transition on OR to state [81]
transition on BITWISE_XOR to state [80]
transition on BITWISE_AND to state [79]
transition on GREATER_EQUAL to state [78]
transition on SEMICOLON to state [221]
transition on NOT_EQUAL to state [77]
transition on LESS to state [76]
transition on LESS_EQUAL to state [75]
transition on BITWISE_OR to state [73]
transition on PLUS to state [72]
transition on EQUAL to state [71]
transition on GREATER to state [70]
transition on MOD to state [69]
transition on MULTIPLY to state [68]
transition on DIVIDE to state [67]
transition on MINUS to state [66]
transition on AND to state [65]

-------------------
lalr_state [221]: {
  [statement ::= RETURN expr SEMICOLON (*) , {IDENTIFIER INT LONG FLOAT DOUBLE BOOL CHAR STRING AUTO IF RETURN BREAK CONTINUE SWITCH END FOR REPEAT FOREACH CONST PRINTLN INPUT }]
}

-------------------
lalr_state [222]: {
  [statement ::= CONTINUE SEMICOLON (*) , {IDENTIFIER INT LONG FLOAT DOUBLE BOOL CHAR STRING AUTO IF RETURN BREAK CONTINUE SWITCH END FOR REPEAT FOREACH CONST PRINTLN INPUT }]
}

-------------------
lalr_state [223]: {
  [base_type ::= (*) BOOL , {RPAREN }]
  [base_type ::= (*) LONG , {RPAREN }]
  [base_type ::= (*) STRING , {RPAREN }]
  [method_cal ::= INPUT LPAREN (*) typeName RPAREN SEMICOLON , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [base_type ::= (*) DOUBLE , {RPAREN }]
  [base_type ::= (*) INT , {RPAREN }]
  [typeName ::= (*) IDENTIFIER , {RPAREN }]
  [base_type ::= (*) CHAR , {RPAREN }]
  [base_type ::= (*) FLOAT , {RPAREN }]
  [method_cal ::= INPUT LPAREN (*) RPAREN SEMICOLON , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
  [typeName ::= (*) base_type , {RPAREN }]
}
transition on CHAR to state [11]
transition on FLOAT to state [21]
transition on base_type to state [30]
transition on typeName to state [225]
transition on IDENTIFIER to state [118]
transition on RPAREN to state [224]
transition on DOUBLE to state [36]
transition on STRING to state [19]
transition on BOOL to state [31]
transition on LONG to state [7]
transition on INT to state [10]

-------------------
lalr_state [224]: {
  [method_cal ::= INPUT LPAREN RPAREN (*) SEMICOLON , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
}
transition on SEMICOLON to state [228]

-------------------
lalr_state [225]: {
  [method_cal ::= INPUT LPAREN typeName (*) RPAREN SEMICOLON , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
}
transition on RPAREN to state [226]

-------------------
lalr_state [226]: {
  [method_cal ::= INPUT LPAREN typeName RPAREN (*) SEMICOLON , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
}
transition on SEMICOLON to state [227]

-------------------
lalr_state [227]: {
  [method_cal ::= INPUT LPAREN typeName RPAREN SEMICOLON (*) , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
}

-------------------
lalr_state [228]: {
  [method_cal ::= INPUT LPAREN RPAREN SEMICOLON (*) , {SEMICOLON PLUS MINUS MULTIPLY DIVIDE MOD BITWISE_AND BITWISE_OR BITWISE_XOR EQUAL NOT_EQUAL LESS_EQUAL LESS GREATER GREATER_EQUAL AND OR RPAREN RBRACKET COMMA }]
}

-------------------
lalr_state [229]: {
  [$START ::= begining EOF (*) , {EOF }]
}

-------------------
------- CUP v0.11b 20160615 (GIT 4ac7450) Parser Generation Summary -------
  0 errors and 19 warnings
  81 terminals, 35 non-terminals, and 127 productions declared, 
  producing 230 unique parse states.
  0 terminals declared but not used.
  0 non-terminals declared but not used.
  0 productions never reduced.
  0 conflicts detected (0 expected).
  Code written to "Parser.java", and "ParserSym.java".
---------------------------------------------------- (CUP v0.11b 20160615 (GIT 4ac7450))
