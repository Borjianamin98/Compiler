package syntax;
import java_cup.runtime.*;

import semantic.syntaxTree.BlockCode;
import semantic.syntaxTree.block.Block;
import semantic.syntaxTree.declaration.*;
import semantic.syntaxTree.expression.Expression;
import semantic.syntaxTree.expression.call.*;
import semantic.syntaxTree.expression.identifier.*;
import semantic.syntaxTree.expression.constValue.*;
import semantic.syntaxTree.expression.operation.arithmetic.*;
import semantic.syntaxTree.expression.operation.bitwise.*;
import semantic.syntaxTree.expression.operation.logical.*;
import semantic.syntaxTree.expression.operation.relational.*;
import semantic.syntaxTree.expression.operation.unary.*;
import semantic.syntaxTree.expression.operation.unary.prefix_postfix.*;
import semantic.syntaxTree.statement.*;
import semantic.syntaxTree.statement.assignment.*;

import semantic.typeTree.TypeTree;

import java.util.ArrayDeque;
import java.util.ArrayList;
import java.util.List;

class Parser;

parser code
{:
    public static List<Expression> list = new ArrayList<>();
    public static ArrayDeque<Object> semanticStack = new ArrayDeque<>();
    public static Object finalR;
:}

/* Terminals (tokens returned by the scanner). */
terminal                                SEMICOLON;
terminal                                PLUS, MINUS, MULTIPLY, DIVIDE, MOD;
terminal                                BITWISE_AND, BITWISE_OR, BITWISE_XOR, BITWISE_NOT;
terminal                                EQUAL, NOT_EQUAL, LESS_EQUAL, LESS, GREATER, GREATER_EQUAL, NOT, AND, OR;
terminal                                UNARY_MINUS;
terminal                                LPAREN, RPAREN, LBRACKET, RBRACKET, LRBRACKET;
terminal String                         IDENTIFIER;
terminal                                RECORD, FUNCTION, EXTERN;
terminal                                INT, LONG, FLOAT, DOUBLE, BOOL, CHAR, STRING, VOID, AUTO;
terminal                                DOT, COMMA, COLON;
terminal                                PLUSPLUS, MINUSMINUS, PLUSPLUS_POSTFIX, MINUSMINUS_POSTFIX;
terminal                                DIRECT_ASSIGN, SUM_ASSIGN, DIFF_ASSIGN, MULT_ASSIGN, DIVIDE_ASSIGN, MOD_ASSIGN;
terminal                                IF, ELSE, RETURN, BREAK, CONTINUE;
terminal                                SWITCH, OF, CASE, DEFAULT, BEGIN, END;
terminal                                FOR, REPEAT, UNTIL, FOREACH, IN;
terminal                                SIZEOF, CONST;
terminal Integer                        INT_CONST;
terminal Long                           LONG_CONST;
terminal Double                         DOUBLE_CONST;
terminal Float                          FLOAT_CONST;
terminal Integer                        BOOL_CONST;
terminal Character                      CHAR_CONST;
terminal String                         STRING_CONST;
terminal                                CAST_PREC;
terminal                                PRINTLN;

/* Non terminals */
non terminal                            program;
non terminal Expression                 method_cal;
non terminal List<Expression>           parameters;
non terminal Variable                   variable;
non terminal String                     base_type, typeName;
non terminal Statement                  assignment;
non terminal Statement                  cond_stmt, loop_stmt;
non terminal Statement                  statement;
non terminal Block                      block;
non terminal                            block_body;
non terminal                            block_part;
non terminal                            else_part, case_part;
non terminal                            for_init_part, for_step_part;
non terminal List<VariableDCLFactory>   const_var_dcl_p, var_dcl_p, var_dcl, var_declrations;
non terminal                            struct_dcl;
non terminal                            function_dcl, func_signature, arguments, argument, extern_dcl;
non terminal Integer                    array_part_no_val;
non terminal Expression                 expr;
non terminal Expression                 const_val;
non terminal                            begining;

/* Precedences */
precedence right MULT_ASSIGN, DIVIDE_ASSIGN, MOD_ASSIGN;
precedence right SUM_ASSIGN, DIFF_ASSIGN;
precedence left OR;
precedence left AND;
precedence left BITWISE_OR;
precedence left BITWISE_XOR;
precedence left BITWISE_AND;
precedence nonassoc EQUAL, NOT_EQUAL;
precedence nonassoc GREATER, GREATER_EQUAL;
precedence nonassoc LESS, LESS_EQUAL;
precedence left PLUS, MINUS;
precedence left MULTIPLY, DIVIDE, MOD;
precedence left SIZEOF;
precedence left CAST_PREC;
precedence right BITWISE_NOT, NOT;
precedence left UNARY_MINUS;
//precedence left LBRACKET;
precedence nonassoc MINUSMINUS, PLUSPLUS;
precedence left DOT;
precedence nonassoc MINUSMINUS_POSTFIX, PLUSPLUS_POSTFIX;

/* The grammar */
start with begining;
program             ::= var_dcl program
                        |
                        function_dcl program
                        |
                        extern_dcl program
                        |
                        struct_dcl program
                        |
                        ;

extern_dcl          ::= EXTERN typeName IDENTIFIER SEMICOLON;

function_dcl        ::= FUNCTION typeName func_signature
                        |
                        FUNCTION VOID func_signature;

func_signature       ::= IDENTIFIER LPAREN arguments RPAREN SEMICOLON
                        |
                        IDENTIFIER LPAREN RPAREN SEMICOLON
                        |
                        IDENTIFIER LPAREN arguments RPAREN block
                        |
                        IDENTIFIER LPAREN RPAREN block
                        ;

arguments           ::= argument COMMA arguments
                        {: System.out.println("argument detected"); :}
                        |
                        argument
                        {: System.out.println("argument detected"); :}
                        ;

argument            ::= typeName IDENTIFIER
                        |
                        typeName IDENTIFIER array_part_no_val;

array_part_no_val   ::= LRBRACKET array_part_no_val:count
                        {: RESULT = 1 + count; :}
                        |

                        {: RESULT = 0; :}
                        ;

struct_dcl          ::= RECORD IDENTIFIER BEGIN var_declrations END RECORD SEMICOLON;

var_declrations     ::= var_dcl:other var_declrations:list
                        {:
                        if (list == null)
                            list = new ArrayList<VariableDCLFactory>();
                        list.addAll(other == null ? new ArrayList<>() : other);
                        RESULT = list;
                        :}
                       |
                       var_dcl:other
                       {: RESULT = other; :}
                       ;

var_dcl             ::= CONST typeName:typeName array_part_no_val:dimensions
                        {:
                        Parser.semanticStack.addLast(VariableDCLFactory.create()
                                                        .setConstant(true)
                                                        .setTypeName(typeName)
                                                        .setDimensions(dimensions));
                        :}
                        const_var_dcl_p:list SEMICOLON
                        {:
                        Parser.semanticStack.removeLast();
                        RESULT = list;
                        :}
                        |
                        typeName:typeName array_part_no_val:dimensions
                        {:
                        Parser.semanticStack.addLast(VariableDCLFactory.create()
                                                        .setConstant(false)
                                                        .setTypeName(typeName)
                                                        .setDimensions(dimensions));
                        :}
                        var_dcl_p:list SEMICOLON
                        {:
                        Parser.semanticStack.removeLast();
                        RESULT = list;
                        :}
                        |
                        CONST AUTO
                        {:
                        Parser.semanticStack.addLast(VariableDCLFactory.create()
                                                        .setConstant(true)
                                                        .setTypeName(TypeTree.AUTO_NAME));
                        :}
                        const_var_dcl_p:list SEMICOLON
                        {:
                        Parser.semanticStack.removeLast();
                        RESULT = list;
                        :}
                        |
                        AUTO
                        {:
                        Parser.semanticStack.addLast(VariableDCLFactory.create()
                                                        .setConstant(false)
                                                        .setTypeName(TypeTree.AUTO_NAME));
                        :}
                        const_var_dcl_p:list SEMICOLON
                        {:
                        Parser.semanticStack.removeLast();
                        RESULT = list;
                        :}
                        ;

const_var_dcl_p     ::= IDENTIFIER:variableName DIRECT_ASSIGN expr:e COMMA const_var_dcl_p:list
                        {:
                        if (list == null)
                            list = new ArrayList<VariableDCLFactory>();
                        VariableDCLFactory factory = (VariableDCLFactory) Parser.semanticStack.getLast();
                        list.add(factory.copy().setVariableName(variableName).setDefaultValue(e));
                        RESULT = list;
                        :}
                        |
                        IDENTIFIER:variableName DIRECT_ASSIGN expr:e
                        {:
                        VariableDCLFactory factory = (VariableDCLFactory) Parser.semanticStack.getLast();
                        RESULT = new ArrayList<VariableDCLFactory>();
                        RESULT.add(factory.copy().setVariableName(variableName).setDefaultValue(e));
                        :}
                        ;


var_dcl_p           ::= IDENTIFIER:variableName COMMA var_dcl_p:list
                        {:
                        if (list == null)
                            list = new ArrayList<VariableDCLFactory>();
                        VariableDCLFactory factory = (VariableDCLFactory) Parser.semanticStack.getLast();
                        list.add(factory.copy().setVariableName(variableName));
                        RESULT = list;
                        :}
                        |
                        IDENTIFIER:variableName
                        {:
                        VariableDCLFactory factory = (VariableDCLFactory) Parser.semanticStack.getLast();
                        RESULT = new ArrayList<VariableDCLFactory>();
                        RESULT.add(factory.copy().setVariableName(variableName));
                        :}
                        |
                        IDENTIFIER:variableName DIRECT_ASSIGN expr:e COMMA var_dcl_p:list
                        {:
                        if (list == null)
                            list = new ArrayList<VariableDCLFactory>();
                        VariableDCLFactory factory = (VariableDCLFactory) Parser.semanticStack.getLast();
                        list.add(factory.copy().setVariableName(variableName).setDefaultValue(e));
                        RESULT = list;
                        :}
                        |
                        IDENTIFIER:variableName DIRECT_ASSIGN expr:e
                        {:
                        VariableDCLFactory factory = (VariableDCLFactory) Parser.semanticStack.getLast();
                        RESULT = new ArrayList<VariableDCLFactory>();
                        RESULT.add(factory.copy().setVariableName(variableName).setDefaultValue(e));
                        :}
                        ;


begining            ::= block:bl
                        {: finalR = bl; :}
                        ;

block               ::= BEGIN
                        {: Parser.semanticStack.addLast(new Block()); :}
                        block_part
                        {: RESULT = (Block) Parser.semanticStack.removeLast(); :}
                        END
                        |
                        BEGIN END
                        {: RESULT = new Block(); :}
                        ;


block_part          ::= block_body
                        |
                        block_body block_part
                        ;

block_body          ::= var_dcl:list
                        {:
                        Block currentBlock = (Block) Parser.semanticStack.getLast();
                        for (VariableDCLFactory variableDCLFactory : list) {
                            currentBlock.addBlockCodes(variableDCLFactory.createMethodVariable());
                        }
                        :}
                        |
                        statement:stat
                        {:
                        Block currentBlock = (Block) Parser.semanticStack.getLast();
                        currentBlock.addBlockCode(stat);
                        :}
                        |
                        method_cal:methodCall SEMICOLON
                        {:
                        Block currentBlock = (Block) Parser.semanticStack.getLast();
                        ((MethodCall) methodCall).setDiscardResult(true);
                        currentBlock.addBlockCode((BlockCode) methodCall);
                        :}
                        |
                        PRINTLN LPAREN expr:e RPAREN SEMICOLON
                        {:
                        Block currentBlock = (Block) Parser.semanticStack.getLast();
                        currentBlock.addBlockCode(new PrintFunction(e));
                        :}
                        |
                        PRINTLN LPAREN RPAREN SEMICOLON
                        {:
                        Block currentBlock = (Block) Parser.semanticStack.getLast();
                        currentBlock.addBlockCode(new PrintFunction());
                        :}
                        ;

statement           ::= assignment:stat SEMICOLON
                        {: RESULT = stat; :}
                        |
                        cond_stmt
                        {: System.out.println("cond_stat"); :}
                        |
                        loop_stmt
                        {: System.out.println("loop_stat"); :}
                        |
                        RETURN SEMICOLON
                        {: System.out.println("return stat"); :}
                        |
                        RETURN expr SEMICOLON
                        {: System.out.println("return expr stat"); :}
                        |
                        BREAK SEMICOLON
                        {: System.out.println("break"); :}
                        |
                        CONTINUE SEMICOLON
                        {: System.out.println("continue"); :}
                        ;

assignment          ::= variable:var DIRECT_ASSIGN expr:e
                        {: RESULT = new DirectAssignment(var, e); :}
                        |
                        variable:var SUM_ASSIGN expr:e
                        {: RESULT = new PlusAssignment(var, e); :}
                        |
                        variable:var DIFF_ASSIGN expr:e
                        {: RESULT = new MinusAssignment(var, e); :}
                        |
                        variable:var MULT_ASSIGN expr:e
                        {: RESULT = new MultiplyAssignment(var, e); :}
                        |
                        variable:var DIVIDE_ASSIGN expr:e
                        {: RESULT = new DivideAssignment(var, e); :}
                        |
                        variable:var MOD_ASSIGN expr:e
                        {: RESULT = new ReminderAssignment(var, e); :}
                        ;

method_cal          ::= IDENTIFIER:methodName LPAREN parameters:parms RPAREN
                        {: RESULT = new MethodCall(methodName, parms); :}
                        ;

parameters          ::= expr:e
                        {: RESULT = new ArrayList<Expression>(e); :}
                        |
                        expr:e COMMA parameters:list
                        {:
                        list.add(e);
                        RESULT = list;
                        :}
                        ;

cond_stmt           ::= IF LPAREN expr RPAREN block else_part
                        {: System.out.println("if condition"); :}
                        |
                        SWITCH LPAREN IDENTIFIER RPAREN OF COLON
                        BEGIN case_part DEFAULT COLON block END
                        {: System.out.println("switch condition"); :}
                        |
                        SWITCH LPAREN IDENTIFIER RPAREN OF COLON
                        BEGIN case_part END
                        {: System.out.println("switch condition"); :}
                        ;

else_part           ::=
                        |
                        ELSE block
                        ;

case_part           ::=
                        |
                        CASE INT_CONST COLON block case_part
                        {: System.out.println("case statement"); :}
                        ;

loop_stmt           ::= FOR LPAREN for_init_part SEMICOLON expr SEMICOLON for_step_part RPAREN block
                        {: System.out.println("for stat"); :}
                        |
                        REPEAT block UNTIL LPAREN expr RPAREN SEMICOLON
                        {: System.out.println("repeat stat"); :}
                        |
                        FOREACH LPAREN IDENTIFIER IN expr RPAREN block
                        {: System.out.println("foreach stat"); :}
                        ;

for_init_part       ::=
                        |
                        assignment;

for_step_part       ::=
                        |
                        assignment
                        |
                        expr;

expr                ::= expr:e1 PLUS expr:e2
                        {: RESULT = new Plus(e1, e2); :}
                        |
                        expr:e1 MINUS expr:e2
                        {: RESULT = new Minus(e1, e2); :}
                        |
                        expr:e1 MULTIPLY expr:e2
                        {: RESULT = new Multiply(e1, e2); :}
                        |
                        expr:e1 DIVIDE expr:e2
                        {: RESULT = new Divide(e1, e2); :}
                        |
                        expr:e1 MOD expr:e2
                        {: RESULT = new Reminder(e1, e2); :}
                        |
                        expr:e1 BITWISE_AND expr:e2
                        {: RESULT = new BitwiseAnd(e1, e2); :}
                        |
                        expr:e1 BITWISE_XOR expr:e2
                        {: RESULT = new BitwiseXOR(e1, e2); :}
                        |
                        expr:e1 BITWISE_OR expr:e2
                        {: RESULT = new BitwiseOr(e1, e2); :}
                        |
                        expr:e1 EQUAL expr:e2
                        {: RESULT = new Equal(e1, e2); :}
                        |
                        expr:e1 NOT_EQUAL expr:e2
                        {: RESULT = new NotEqual(e1, e2); :}
                        |
                        expr:e1 GREATER_EQUAL expr:e2
                        {: RESULT = new GreaterEqual(e1, e2); :}
                        |
                        expr:e1 LESS_EQUAL expr:e2
                        {: RESULT = new LessEqual(e1, e2); :}
                        |
                        expr:e1 GREATER expr:e2
                        {: RESULT = new Greater(e1, e2); :}
                        |
                        expr:e1 LESS expr:e2
                        {: RESULT = new Less(e1, e2); :}
                        |
                        expr:e1 AND expr:e2
                        {: RESULT = new And(e1, e2); :}
                        |
                        expr:e1 OR expr:e2
                        {: RESULT = new Or(e1, e2); :}
                        |
                        LPAREN expr:val RPAREN
                        {: RESULT = val; :}
                        |
                        variable:var
                        {: RESULT = var; :}
                        |
                        MINUSMINUS variable:var
                        {: RESULT = new MinusMinusPrefix(var); :}
                        |
                        PLUSPLUS variable:var
                        {: RESULT = new PlusPlusPrefix(var); :}
                        |
                        variable:var MINUSMINUS
                        {: RESULT = new MinusMinusPostfix(var); :}
                        %prec MINUSMINUS_POSTFIX
                        |
                        variable:var PLUSPLUS
                        {: RESULT = new PlusPlusPostfix(var); :}
                        %prec PLUSPLUS_POSTFIX
                        |
                        method_cal
                        {: System.out.println("method call"); :}
                        |
                        MINUS expr:e
                        {: RESULT = new Neg(e); :}
                        %prec UNARY_MINUS
                        |
                        BITWISE_NOT expr:e
                        {: RESULT = new BitwiseNot(e); :}
                        |
                        NOT expr:e
                        {: RESULT = new Not(e); :}
                        |
                        const_val:val
                        {: RESULT = val; :}
                        |
                        SIZEOF LPAREN typeName:typeName RPAREN
                        {: RESULT = new Sizeof(typeName); :}
                        |
                        LPAREN base_type:typeName RPAREN expr:e
                        {: RESULT = new Cast(typeName, e); :}
                        %prec CAST_PREC
                        ;

base_type           ::= INT
                        {: RESULT = TypeTree.INTEGER_NAME; :}
                        |
                        LONG
                        {: RESULT = TypeTree.LONG_NAME; :}
                        |
                        FLOAT
                        {: RESULT = TypeTree.FLOAT_NAME; :}
                        |
                        DOUBLE
                        {: RESULT = TypeTree.DOUBLE_NAME; :}
                        |
                        BOOL
                        {: RESULT = TypeTree.BOOLEAN_NAME; :}
                        |
                        CHAR
                        {: RESULT = TypeTree.CHAR_NAME; :}
                        |
                        STRING
                        {: RESULT = TypeTree.STRING_NAME; :}
                        ;

typeName                ::= base_type:typeName
                        {: RESULT = typeName; :}
                        |
                        IDENTIFIER:name
                        {: RESULT = name; :}
                        ;

variable            ::= IDENTIFIER:name
                        {: RESULT = new SimpleVariable(name); :}
                        |
                        variable:var LBRACKET expr:requestedDimension RBRACKET
                        {: RESULT = new ArrayVariable(var, requestedDimension); :}
                        |
                        variable:parent DOT IDENTIFIER:memberName
                        {: RESULT = new MemberVariable(parent, memberName); :}
                        ;

const_val           ::= INT_CONST:val
                        {: RESULT = new IntegerConst(val); :}
                        |
                        LONG_CONST:val
                        {: RESULT = new LongConst(val); :}
                        |
                        DOUBLE_CONST:val
                        {: RESULT = new DoubleConst(val); :}
                        |
                        FLOAT_CONST:val
                        {: RESULT = new FloatConst(val); :}
                        |
                        CHAR_CONST:val
                        {: RESULT = new CharConst(val); :}
                        |
                        BOOL_CONST:val
                        {: RESULT = new BooleanConst(val); :}
                        |
                        STRING_CONST:val
                        {: RESULT = new StringConst(val); :}
                        ;